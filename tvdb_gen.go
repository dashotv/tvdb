// Package tvdb provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package tvdb

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for GetEpisodeExtendedParamsMeta.
const (
	GetEpisodeExtendedParamsMetaTranslations GetEpisodeExtendedParamsMeta = "translations"
)

// Defines values for GetMoviesFilterParamsGenre.
const (
	GetMoviesFilterParamsGenreN1  GetMoviesFilterParamsGenre = 1
	GetMoviesFilterParamsGenreN10 GetMoviesFilterParamsGenre = 10
	GetMoviesFilterParamsGenreN11 GetMoviesFilterParamsGenre = 11
	GetMoviesFilterParamsGenreN12 GetMoviesFilterParamsGenre = 12
	GetMoviesFilterParamsGenreN13 GetMoviesFilterParamsGenre = 13
	GetMoviesFilterParamsGenreN14 GetMoviesFilterParamsGenre = 14
	GetMoviesFilterParamsGenreN15 GetMoviesFilterParamsGenre = 15
	GetMoviesFilterParamsGenreN16 GetMoviesFilterParamsGenre = 16
	GetMoviesFilterParamsGenreN17 GetMoviesFilterParamsGenre = 17
	GetMoviesFilterParamsGenreN18 GetMoviesFilterParamsGenre = 18
	GetMoviesFilterParamsGenreN19 GetMoviesFilterParamsGenre = 19
	GetMoviesFilterParamsGenreN2  GetMoviesFilterParamsGenre = 2
	GetMoviesFilterParamsGenreN21 GetMoviesFilterParamsGenre = 21
	GetMoviesFilterParamsGenreN22 GetMoviesFilterParamsGenre = 22
	GetMoviesFilterParamsGenreN23 GetMoviesFilterParamsGenre = 23
	GetMoviesFilterParamsGenreN24 GetMoviesFilterParamsGenre = 24
	GetMoviesFilterParamsGenreN25 GetMoviesFilterParamsGenre = 25
	GetMoviesFilterParamsGenreN26 GetMoviesFilterParamsGenre = 26
	GetMoviesFilterParamsGenreN27 GetMoviesFilterParamsGenre = 27
	GetMoviesFilterParamsGenreN28 GetMoviesFilterParamsGenre = 28
	GetMoviesFilterParamsGenreN29 GetMoviesFilterParamsGenre = 29
	GetMoviesFilterParamsGenreN3  GetMoviesFilterParamsGenre = 3
	GetMoviesFilterParamsGenreN30 GetMoviesFilterParamsGenre = 30
	GetMoviesFilterParamsGenreN31 GetMoviesFilterParamsGenre = 31
	GetMoviesFilterParamsGenreN32 GetMoviesFilterParamsGenre = 32
	GetMoviesFilterParamsGenreN33 GetMoviesFilterParamsGenre = 33
	GetMoviesFilterParamsGenreN34 GetMoviesFilterParamsGenre = 34
	GetMoviesFilterParamsGenreN35 GetMoviesFilterParamsGenre = 35
	GetMoviesFilterParamsGenreN36 GetMoviesFilterParamsGenre = 36
	GetMoviesFilterParamsGenreN4  GetMoviesFilterParamsGenre = 4
	GetMoviesFilterParamsGenreN5  GetMoviesFilterParamsGenre = 5
	GetMoviesFilterParamsGenreN6  GetMoviesFilterParamsGenre = 6
	GetMoviesFilterParamsGenreN7  GetMoviesFilterParamsGenre = 7
	GetMoviesFilterParamsGenreN8  GetMoviesFilterParamsGenre = 8
	GetMoviesFilterParamsGenreN9  GetMoviesFilterParamsGenre = 9
)

// Defines values for GetMoviesFilterParamsSort.
const (
	GetMoviesFilterParamsSortFirstAired GetMoviesFilterParamsSort = "firstAired"
	GetMoviesFilterParamsSortName       GetMoviesFilterParamsSort = "name"
	GetMoviesFilterParamsSortScore      GetMoviesFilterParamsSort = "score"
)

// Defines values for GetMoviesFilterParamsStatus.
const (
	GetMoviesFilterParamsStatusN1 GetMoviesFilterParamsStatus = 1
	GetMoviesFilterParamsStatusN2 GetMoviesFilterParamsStatus = 2
	GetMoviesFilterParamsStatusN3 GetMoviesFilterParamsStatus = 3
)

// Defines values for GetMovieExtendedParamsMeta.
const (
	GetMovieExtendedParamsMetaTranslations GetMovieExtendedParamsMeta = "translations"
)

// Defines values for GetMovieExtendedParamsShort.
const (
	GetMovieExtendedParamsShortFalse GetMovieExtendedParamsShort = false
	GetMovieExtendedParamsShortTrue  GetMovieExtendedParamsShort = true
)

// Defines values for GetPeopleExtendedParamsMeta.
const (
	GetPeopleExtendedParamsMetaTranslations GetPeopleExtendedParamsMeta = "translations"
)

// Defines values for GetSeriesFilterParamsGenre.
const (
	GetSeriesFilterParamsGenreN1  GetSeriesFilterParamsGenre = 1
	GetSeriesFilterParamsGenreN10 GetSeriesFilterParamsGenre = 10
	GetSeriesFilterParamsGenreN11 GetSeriesFilterParamsGenre = 11
	GetSeriesFilterParamsGenreN12 GetSeriesFilterParamsGenre = 12
	GetSeriesFilterParamsGenreN13 GetSeriesFilterParamsGenre = 13
	GetSeriesFilterParamsGenreN14 GetSeriesFilterParamsGenre = 14
	GetSeriesFilterParamsGenreN15 GetSeriesFilterParamsGenre = 15
	GetSeriesFilterParamsGenreN16 GetSeriesFilterParamsGenre = 16
	GetSeriesFilterParamsGenreN17 GetSeriesFilterParamsGenre = 17
	GetSeriesFilterParamsGenreN18 GetSeriesFilterParamsGenre = 18
	GetSeriesFilterParamsGenreN19 GetSeriesFilterParamsGenre = 19
	GetSeriesFilterParamsGenreN2  GetSeriesFilterParamsGenre = 2
	GetSeriesFilterParamsGenreN21 GetSeriesFilterParamsGenre = 21
	GetSeriesFilterParamsGenreN22 GetSeriesFilterParamsGenre = 22
	GetSeriesFilterParamsGenreN23 GetSeriesFilterParamsGenre = 23
	GetSeriesFilterParamsGenreN24 GetSeriesFilterParamsGenre = 24
	GetSeriesFilterParamsGenreN25 GetSeriesFilterParamsGenre = 25
	GetSeriesFilterParamsGenreN26 GetSeriesFilterParamsGenre = 26
	GetSeriesFilterParamsGenreN27 GetSeriesFilterParamsGenre = 27
	GetSeriesFilterParamsGenreN28 GetSeriesFilterParamsGenre = 28
	GetSeriesFilterParamsGenreN29 GetSeriesFilterParamsGenre = 29
	GetSeriesFilterParamsGenreN3  GetSeriesFilterParamsGenre = 3
	GetSeriesFilterParamsGenreN30 GetSeriesFilterParamsGenre = 30
	GetSeriesFilterParamsGenreN31 GetSeriesFilterParamsGenre = 31
	GetSeriesFilterParamsGenreN32 GetSeriesFilterParamsGenre = 32
	GetSeriesFilterParamsGenreN33 GetSeriesFilterParamsGenre = 33
	GetSeriesFilterParamsGenreN34 GetSeriesFilterParamsGenre = 34
	GetSeriesFilterParamsGenreN35 GetSeriesFilterParamsGenre = 35
	GetSeriesFilterParamsGenreN36 GetSeriesFilterParamsGenre = 36
	GetSeriesFilterParamsGenreN4  GetSeriesFilterParamsGenre = 4
	GetSeriesFilterParamsGenreN5  GetSeriesFilterParamsGenre = 5
	GetSeriesFilterParamsGenreN6  GetSeriesFilterParamsGenre = 6
	GetSeriesFilterParamsGenreN7  GetSeriesFilterParamsGenre = 7
	GetSeriesFilterParamsGenreN8  GetSeriesFilterParamsGenre = 8
	GetSeriesFilterParamsGenreN9  GetSeriesFilterParamsGenre = 9
)

// Defines values for GetSeriesFilterParamsSort.
const (
	GetSeriesFilterParamsSortFirstAired GetSeriesFilterParamsSort = "firstAired"
	GetSeriesFilterParamsSortLastAired  GetSeriesFilterParamsSort = "lastAired"
	GetSeriesFilterParamsSortName       GetSeriesFilterParamsSort = "name"
	GetSeriesFilterParamsSortScore      GetSeriesFilterParamsSort = "score"
)

// Defines values for GetSeriesFilterParamsSortType.
const (
	Asc  GetSeriesFilterParamsSortType = "asc"
	Desc GetSeriesFilterParamsSortType = "desc"
)

// Defines values for GetSeriesFilterParamsStatus.
const (
	GetSeriesFilterParamsStatusN1 GetSeriesFilterParamsStatus = 1
	GetSeriesFilterParamsStatusN2 GetSeriesFilterParamsStatus = 2
	GetSeriesFilterParamsStatusN3 GetSeriesFilterParamsStatus = 3
)

// Defines values for GetSeriesExtendedParamsMeta.
const (
	GetSeriesExtendedParamsMetaEpisodes     GetSeriesExtendedParamsMeta = "episodes"
	GetSeriesExtendedParamsMetaTranslations GetSeriesExtendedParamsMeta = "translations"
)

// Defines values for GetSeriesExtendedParamsShort.
const (
	GetSeriesExtendedParamsShortFalse GetSeriesExtendedParamsShort = false
	GetSeriesExtendedParamsShortTrue  GetSeriesExtendedParamsShort = true
)

// Defines values for UpdatesParamsType.
const (
	UpdatesParamsTypeArtwork              UpdatesParamsType = "artwork"
	UpdatesParamsTypeArtworktypes         UpdatesParamsType = "artworktypes"
	UpdatesParamsTypeAwardCategories      UpdatesParamsType = "award_categories"
	UpdatesParamsTypeAwardNominees        UpdatesParamsType = "award_nominees"
	UpdatesParamsTypeAwards               UpdatesParamsType = "awards"
	UpdatesParamsTypeCompanies            UpdatesParamsType = "companies"
	UpdatesParamsTypeCompanyTypes         UpdatesParamsType = "company_types"
	UpdatesParamsTypeContentRatings       UpdatesParamsType = "content_ratings"
	UpdatesParamsTypeCountries            UpdatesParamsType = "countries"
	UpdatesParamsTypeEntityTypes          UpdatesParamsType = "entity_types"
	UpdatesParamsTypeEpisodes             UpdatesParamsType = "episodes"
	UpdatesParamsTypeGenres               UpdatesParamsType = "genres"
	UpdatesParamsTypeLanguages            UpdatesParamsType = "languages"
	UpdatesParamsTypeLists                UpdatesParamsType = "lists"
	UpdatesParamsTypeMovieGenres          UpdatesParamsType = "movie_genres"
	UpdatesParamsTypeMovieStatus          UpdatesParamsType = "movie_status"
	UpdatesParamsTypeMovies               UpdatesParamsType = "movies"
	UpdatesParamsTypePeople               UpdatesParamsType = "people"
	UpdatesParamsTypePeopletypes          UpdatesParamsType = "peopletypes"
	UpdatesParamsTypeSeasons              UpdatesParamsType = "seasons"
	UpdatesParamsTypeSeasontypes          UpdatesParamsType = "seasontypes"
	UpdatesParamsTypeSeries               UpdatesParamsType = "series"
	UpdatesParamsTypeSeriespeople         UpdatesParamsType = "seriespeople"
	UpdatesParamsTypeSourcetypes          UpdatesParamsType = "sourcetypes"
	UpdatesParamsTypeTagOptions           UpdatesParamsType = "tag_options"
	UpdatesParamsTypeTags                 UpdatesParamsType = "tags"
	UpdatesParamsTypeTranslatedcharacters UpdatesParamsType = "translatedcharacters"
	UpdatesParamsTypeTranslatedcompanies  UpdatesParamsType = "translatedcompanies"
	UpdatesParamsTypeTranslatedepisodes   UpdatesParamsType = "translatedepisodes"
	UpdatesParamsTypeTranslatedlists      UpdatesParamsType = "translatedlists"
	UpdatesParamsTypeTranslatedmovies     UpdatesParamsType = "translatedmovies"
	UpdatesParamsTypeTranslatedpeople     UpdatesParamsType = "translatedpeople"
	UpdatesParamsTypeTranslatedseasons    UpdatesParamsType = "translatedseasons"
	UpdatesParamsTypeTranslatedserierk    UpdatesParamsType = "translatedserierk"
)

// Defines values for UpdatesParamsAction.
const (
	Delete UpdatesParamsAction = "delete"
	Update UpdatesParamsAction = "update"
)

// Alias An alias model, which can be associated with a series, season, movie, person, or list.
type Alias struct {
	// Language A 3-4 character string indicating the language of the alias, as defined in Language.
	Language *string `json:"language,omitempty"`

	// Name A string containing the alias itself.
	Name *string `json:"name,omitempty"`
}

// ArtworkBaseRecord base artwork record
type ArtworkBaseRecord struct {
	Height       *int64   `json:"height,omitempty"`
	Id           *int     `json:"id,omitempty"`
	Image        *string  `json:"image,omitempty"`
	IncludesText *bool    `json:"includesText,omitempty"`
	Language     *string  `json:"language,omitempty"`
	Score        *float32 `json:"score,omitempty"`
	Thumbnail    *string  `json:"thumbnail,omitempty"`

	// Type The artwork type corresponds to the ids from the /artwork/types endpoint.
	Type  *int64 `json:"type,omitempty"`
	Width *int64 `json:"width,omitempty"`
}

// ArtworkExtendedRecord extended artwork record
type ArtworkExtendedRecord struct {
	EpisodeId      *int     `json:"episodeId,omitempty"`
	Height         *int64   `json:"height,omitempty"`
	ID             *int64   `json:"id,omitempty"`
	Image          *string  `json:"image,omitempty"`
	IncludesText   *bool    `json:"includesText,omitempty"`
	Language       *string  `json:"language,omitempty"`
	MovieId        *int     `json:"movieId,omitempty"`
	NetworkId      *int     `json:"networkId,omitempty"`
	PeopleId       *int     `json:"peopleId,omitempty"`
	Score          *float32 `json:"score,omitempty"`
	SeasonId       *int     `json:"seasonId,omitempty"`
	SeriesId       *int     `json:"seriesId,omitempty"`
	SeriesPeopleId *int     `json:"seriesPeopleId,omitempty"`

	// Status artwork status record
	Status          *ArtworkStatus `json:"status,omitempty"`
	TagOptions      *[]TagOption   `json:"tagOptions,omitempty"`
	Thumbnail       *string        `json:"thumbnail,omitempty"`
	ThumbnailHeight *int64         `json:"thumbnailHeight,omitempty"`
	ThumbnailWidth  *int64         `json:"thumbnailWidth,omitempty"`

	// Type The artwork type corresponds to the ids from the /artwork/types endpoint.
	Type      *int64 `json:"type,omitempty"`
	UpdatedAt *int64 `json:"updatedAt,omitempty"`
	Width     *int64 `json:"width,omitempty"`
}

// ArtworkStatus artwork status record
type ArtworkStatus struct {
	ID   *int64  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// ArtworkType artwork type record
type ArtworkType struct {
	Height      *int64  `json:"height,omitempty"`
	ID          *int64  `json:"id,omitempty"`
	ImageFormat *string `json:"imageFormat,omitempty"`
	Name        *string `json:"name,omitempty"`
	RecordType  *string `json:"recordType,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	ThumbHeight *int64  `json:"thumbHeight,omitempty"`
	ThumbWidth  *int64  `json:"thumbWidth,omitempty"`
	Width       *int64  `json:"width,omitempty"`
}

// AwardBaseRecord base award record
type AwardBaseRecord struct {
	Id   *int    `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// AwardCategoryBaseRecord base award category record
type AwardCategoryBaseRecord struct {
	AllowCoNominees *bool `json:"allowCoNominees,omitempty"`

	// Award base award record
	Award     *AwardBaseRecord `json:"award,omitempty"`
	ForMovies *bool            `json:"forMovies,omitempty"`
	ForSeries *bool            `json:"forSeries,omitempty"`
	ID        *int64           `json:"id,omitempty"`
	Name      *string          `json:"name,omitempty"`
}

// AwardCategoryExtendedRecord extended award category record
type AwardCategoryExtendedRecord struct {
	AllowCoNominees *bool `json:"allowCoNominees,omitempty"`

	// Award base award record
	Award     *AwardBaseRecord          `json:"award,omitempty"`
	ForMovies *bool                     `json:"forMovies,omitempty"`
	ForSeries *bool                     `json:"forSeries,omitempty"`
	ID        *int64                    `json:"id,omitempty"`
	Name      *string                   `json:"name,omitempty"`
	Nominees  *[]AwardNomineeBaseRecord `json:"nominees,omitempty"`
}

// AwardExtendedRecord extended award record
type AwardExtendedRecord struct {
	Categories *[]AwardCategoryBaseRecord `json:"categories,omitempty"`
	Id         *int                       `json:"id,omitempty"`
	Name       *string                    `json:"name,omitempty"`
	Score      *int64                     `json:"score,omitempty"`
}

// AwardNomineeBaseRecord base award nominee record
type AwardNomineeBaseRecord struct {
	Category *string `json:"category,omitempty"`

	// Character character record
	Character *Character `json:"character,omitempty"`
	Details   *string    `json:"details,omitempty"`

	// Episode base episode record
	Episode  *EpisodeBaseRecord `json:"episode,omitempty"`
	ID       *int64             `json:"id,omitempty"`
	IsWinner *bool              `json:"isWinner,omitempty"`

	// Movie base movie record
	Movie *MovieBaseRecord `json:"movie,omitempty"`
	Name  *string          `json:"name,omitempty"`

	// Series The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
	Series *SeriesBaseRecord `json:"series,omitempty"`
	Year   *string           `json:"year,omitempty"`
}

// Biography biography record
type Biography struct {
	Biography *string `json:"biography,omitempty"`
	Language  *string `json:"language,omitempty"`
}

// Character character record
type Character struct {
	Aliases *[]Alias `json:"aliases,omitempty"`

	// Episode base record info
	Episode    *RecordInfo `json:"episode,omitempty"`
	EpisodeId  *int        `json:"episodeId,omitempty"`
	ID         *int64      `json:"id,omitempty"`
	Image      *string     `json:"image,omitempty"`
	IsFeatured *bool       `json:"isFeatured,omitempty"`

	// Movie base record info
	Movie                *RecordInfo `json:"movie,omitempty"`
	MovieId              *int        `json:"movieId,omitempty"`
	Name                 *string     `json:"name,omitempty"`
	NameTranslations     *[]string   `json:"nameTranslations,omitempty"`
	OverviewTranslations *[]string   `json:"overviewTranslations,omitempty"`
	PeopleId             *int        `json:"peopleId,omitempty"`
	PeopleType           *string     `json:"peopleType,omitempty"`
	PersonImgURL         *string     `json:"personImgURL,omitempty"`
	PersonName           *string     `json:"personName,omitempty"`

	// Series base record info
	Series     *RecordInfo  `json:"series,omitempty"`
	SeriesId   *int         `json:"seriesId,omitempty"`
	Sort       *int64       `json:"sort,omitempty"`
	TagOptions *[]TagOption `json:"tagOptions,omitempty"`
	Type       *int64       `json:"type,omitempty"`
	URL        *string      `json:"url,omitempty"`
}

// Companies Companies by type record
type Companies struct {
	// Distributor A company record
	Distributor *[]Company `json:"distributor,omitempty"`

	// Network A company record
	Network *[]Company `json:"network,omitempty"`

	// Production A company record
	Production *[]Company `json:"production,omitempty"`

	// SpecialEffects A company record
	SpecialEffects *[]Company `json:"special_effects,omitempty"`

	// Studio A company record
	Studio *[]Company `json:"studio,omitempty"`
}

// Company A company record
type Company struct {
	ActiveDate           *string   `json:"activeDate,omitempty"`
	Aliases              *[]Alias  `json:"aliases,omitempty"`
	Country              *string   `json:"country,omitempty"`
	ID                   *int64    `json:"id,omitempty"`
	InactiveDate         *string   `json:"inactiveDate,omitempty"`
	Name                 *string   `json:"name,omitempty"`
	NameTranslations     *[]string `json:"nameTranslations,omitempty"`
	OverviewTranslations *[]string `json:"overviewTranslations,omitempty"`

	// ParentCompany A parent company record
	ParentCompany      *ParentCompany `json:"parentCompany,omitempty"`
	PrimaryCompanyType *int64         `json:"primaryCompanyType,omitempty"`
	Slug               *string        `json:"slug,omitempty"`
	TagOptions         *[]TagOption   `json:"tagOptions,omitempty"`
}

// CompanyRelationShip A company relationship
type CompanyRelationShip struct {
	Id       *int    `json:"id,omitempty"`
	TypeName *string `json:"typeName,omitempty"`
}

// CompanyType A company type record
type CompanyType struct {
	CompanyTypeId   *int    `json:"companyTypeId,omitempty"`
	CompanyTypeName *string `json:"companyTypeName,omitempty"`
}

// ContentRating content rating record
type ContentRating struct {
	ContentType *string `json:"contentType,omitempty"`
	Country     *string `json:"country,omitempty"`
	Description *string `json:"description,omitempty"`
	FullName    *string `json:"fullName,omitempty"`
	ID          *int64  `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	Order       *int    `json:"order,omitempty"`
}

// Country country record
type Country struct {
	ID        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
	ShortCode *string `json:"shortCode,omitempty"`
}

// Entity Entity record
type Entity struct {
	MovieId  *int   `json:"movieId,omitempty"`
	Order    *int64 `json:"order,omitempty"`
	SeriesId *int   `json:"seriesId,omitempty"`
}

// EntityType Entity Type record
type EntityType struct {
	HasSpecials *bool   `json:"hasSpecials,omitempty"`
	Id          *int    `json:"id,omitempty"`
	Order       *string `json:"name,omitempty"`
}

// EntityUpdate entity update record
type EntityUpdate struct {
	EnitityType       *string `json:"entityType,omitempty"`
	ExtraInfo         *string `json:"extraInfo,omitempty"`
	MergeToEntityType *string `json:"mergeToEntityType,omitempty"`
	MergeToId         *int64  `json:"mergeToId,omitempty"`
	Method            *string `json:"method,omitempty"`
	MethodInt         *int    `json:"methodInt,omitempty"`
	RecordID          *int64  `json:"recordId,omitempty"`
	RecordType        *string `json:"recordType,omitempty"`

	// SeriesId Only present for episodes records
	SeriesID  *int64 `json:"seriesId,omitempty"`
	TimeStamp *int64 `json:"timeStamp,omitempty"`
	UserId    *int   `json:"userId,omitempty"`
}

// EpisodeBaseRecord base episode record
type EpisodeBaseRecord struct {
	Aired             *string `json:"aired,omitempty"`
	AirsAfterSeason   *int    `json:"airsAfterSeason,omitempty"`
	AirsBeforeEpisode *int    `json:"airsBeforeEpisode,omitempty"`
	AirsBeforeSeason  *int    `json:"airsBeforeSeason,omitempty"`

	// FinaleType season, midseason, or series
	FinaleType           *string             `json:"finaleType,omitempty"`
	ID                   *int64              `json:"id,omitempty"`
	Image                *string             `json:"image,omitempty"`
	ImageType            *int                `json:"imageType,omitempty"`
	IsMovie              *int64              `json:"isMovie,omitempty"`
	LastUpdated          *string             `json:"lastUpdated,omitempty"`
	LinkedMovie          *int                `json:"linkedMovie,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	NameTranslations     *[]string           `json:"nameTranslations,omitempty"`
	Number               *int                `json:"number,omitempty"`
	Overview             *string             `json:"overview,omitempty"`
	OverviewTranslations *[]string           `json:"overviewTranslations,omitempty"`
	Runtime              *int                `json:"runtime,omitempty"`
	SeasonName           *string             `json:"seasonName,omitempty"`
	SeasonNumber         *int                `json:"seasonNumber,omitempty"`
	Seasons              *[]SeasonBaseRecord `json:"seasons,omitempty"`
	SeriesID             *int64              `json:"seriesId,omitempty"`
	Year                 *string             `json:"year,omitempty"`
}

// EpisodeExtendedRecord extended episode record
type EpisodeExtendedRecord struct {
	Aired             *string            `json:"aired,omitempty"`
	AirsAfterSeason   *int               `json:"airsAfterSeason,omitempty"`
	AirsBeforeEpisode *int               `json:"airsBeforeEpisode,omitempty"`
	AirsBeforeSeason  *int               `json:"airsBeforeSeason,omitempty"`
	Awards            *[]AwardBaseRecord `json:"awards,omitempty"`
	Characters        *[]Character       `json:"characters,omitempty"`
	Companies         *[]Company         `json:"companies,omitempty"`
	ContentRatings    *[]ContentRating   `json:"contentRatings,omitempty"`

	// FinaleType season, midseason, or series
	FinaleType           *string                   `json:"finaleType,omitempty"`
	ID                   *int64                    `json:"id,omitempty"`
	Image                *string                   `json:"image,omitempty"`
	ImageType            *int                      `json:"imageType,omitempty"`
	IsMovie              *int64                    `json:"isMovie,omitempty"`
	LastUpdated          *string                   `json:"lastUpdated,omitempty"`
	LinkedMovie          *int                      `json:"linkedMovie,omitempty"`
	Name                 *string                   `json:"name,omitempty"`
	NameTranslations     *[]string                 `json:"nameTranslations,omitempty"`
	Networks             *[]Company                `json:"networks,omitempty"`
	Nominees             *[]AwardNomineeBaseRecord `json:"nominations,omitempty"`
	Number               *int                      `json:"number,omitempty"`
	Overview             *string                   `json:"overview,omitempty"`
	OverviewTranslations *[]string                 `json:"overviewTranslations,omitempty"`
	ProductionCode       *string                   `json:"productionCode,omitempty"`
	RemoteIDs            *[]RemoteID               `json:"remoteIds,omitempty"`
	Runtime              *int                      `json:"runtime,omitempty"`
	SeasonNumber         *int                      `json:"seasonNumber,omitempty"`
	Seasons              *[]SeasonBaseRecord       `json:"seasons,omitempty"`
	SeriesID             *int64                    `json:"seriesId,omitempty"`
	Studios              *[]Company                `json:"studios,omitempty"`
	TagOptions           *[]TagOption              `json:"tagOptions,omitempty"`
	Trailers             *[]Trailer                `json:"trailers,omitempty"`

	// Translations translation extended record
	Translations *TranslationExtended `json:"translations,omitempty"`
	Year         *string              `json:"year,omitempty"`
}

// FavoriteRecord Favorites record
type FavoriteRecord struct {
	Artwork  *int `json:"artwork,omitempty"`
	Episodes *int `json:"episode,omitempty"`
	List     *int `json:"list,omitempty"`
	Movies   *int `json:"movie,omitempty"`
	People   *int `json:"people,omitempty"`
	Series   *int `json:"series,omitempty"`
}

// Favorites User favorites record
type Favorites struct {
	Artwork  *[]int `json:"artwork,omitempty"`
	Episodes *[]int `json:"episodes,omitempty"`
	List     *[]int `json:"lists,omitempty"`
	Movies   *[]int `json:"movies,omitempty"`
	People   *[]int `json:"people,omitempty"`
	Series   *[]int `json:"series,omitempty"`
}

// Gender gender record
type Gender struct {
	ID   *int64  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// GenreBaseRecord base genre record
type GenreBaseRecord struct {
	ID   *int64  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// Inspiration Movie inspiration record
type Inspiration struct {
	ID       *int64  `json:"id,omitempty"`
	Type     *string `json:"type,omitempty"`
	TypeName *string `json:"type_name,omitempty"`
	Url      *string `json:"url,omitempty"`
}

// InspirationType Movie inspiration type record
type InspirationType struct {
	Description   *string `json:"description,omitempty"`
	ID            *int64  `json:"id,omitempty"`
	Name          *string `json:"name,omitempty"`
	ReferenceName *string `json:"reference_name,omitempty"`
	Url           *string `json:"url,omitempty"`
}

// Language language record
type Language struct {
	ID         *string `json:"id,omitempty"`
	Name       *string `json:"name,omitempty"`
	NativeName *string `json:"nativeName,omitempty"`
	ShortCode  *string `json:"shortCode,omitempty"`
}

// Links Links for next, previous and current record
type Links struct {
	Next       *string `json:"next,omitempty"`
	PageSize   *int    `json:"page_size,omitempty"`
	Prev       *string `json:"prev,omitempty"`
	Self       *string `json:"self,omitempty"`
	TotalItems *int    `json:"total_items,omitempty"`
}

// ListBaseRecord base list record
type ListBaseRecord struct {
	Aliases              *[]Alias     `json:"aliases,omitempty"`
	ID                   *int64       `json:"id,omitempty"`
	Image                *string      `json:"image,omitempty"`
	ImageIsFallback      *bool        `json:"imageIsFallback,omitempty"`
	IsOfficial           *bool        `json:"isOfficial,omitempty"`
	Name                 *string      `json:"name,omitempty"`
	NameTranslations     *[]string    `json:"nameTranslations,omitempty"`
	Overview             *string      `json:"overview,omitempty"`
	OverviewTranslations *[]string    `json:"overviewTranslations,omitempty"`
	RemoteIDs            *[]RemoteID  `json:"remoteIds,omitempty"`
	Score                *int         `json:"score,omitempty"`
	TagOptions           *[]TagOption `json:"tags,omitempty"`
	Url                  *string      `json:"url,omitempty"`
}

// ListExtendedRecord extended list record
type ListExtendedRecord struct {
	Aliases              *[]Alias  `json:"aliases,omitempty"`
	Entities             *[]Entity `json:"entities,omitempty"`
	ID                   *int64    `json:"id,omitempty"`
	Image                *string   `json:"image,omitempty"`
	ImageIsFallback      *bool     `json:"imageIsFallback,omitempty"`
	IsOfficial           *bool     `json:"isOfficial,omitempty"`
	Name                 *string   `json:"name,omitempty"`
	NameTranslations     *[]string `json:"nameTranslations,omitempty"`
	Overview             *string   `json:"overview,omitempty"`
	OverviewTranslations *[]string `json:"overviewTranslations,omitempty"`
	Score                *int64    `json:"score,omitempty"`
	Url                  *string   `json:"url,omitempty"`
}

// MovieBaseRecord base movie record
type MovieBaseRecord struct {
	Aliases              *[]Alias  `json:"aliases,omitempty"`
	ID                   *int64    `json:"id,omitempty"`
	Image                *string   `json:"image,omitempty"`
	LastUpdated          *string   `json:"lastUpdated,omitempty"`
	Name                 *string   `json:"name,omitempty"`
	NameTranslations     *[]string `json:"nameTranslations,omitempty"`
	OverviewTranslations *[]string `json:"overviewTranslations,omitempty"`
	Runtime              *int      `json:"runtime,omitempty"`
	Score                *float64  `json:"score,omitempty"`
	Slug                 *string   `json:"slug,omitempty"`

	// Status status record
	Status *Status `json:"status,omitempty"`
	Year   *string `json:"year,omitempty"`
}

// MovieExtendedRecord extended movie record
type MovieExtendedRecord struct {
	Aliases        *[]Alias             `json:"aliases,omitempty"`
	Artworks       *[]ArtworkBaseRecord `json:"artworks,omitempty"`
	AudioLanguages *[]string            `json:"audioLanguages,omitempty"`
	Awards         *[]AwardBaseRecord   `json:"awards,omitempty"`
	BoxOffice      *string              `json:"boxOffice,omitempty"`
	BoxOfficeUS    *string              `json:"boxOfficeUS,omitempty"`
	Budget         *string              `json:"budget,omitempty"`
	Characters     *[]Character         `json:"characters,omitempty"`

	// Companies Companies by type record
	Companies      *Companies       `json:"companies,omitempty"`
	ContentRatings *[]ContentRating `json:"contentRatings,omitempty"`

	// FirstRelease release record
	FirstRelease         *Release             `json:"first_release,omitempty"`
	Genres               *[]GenreBaseRecord   `json:"genres,omitempty"`
	ID                   *int64               `json:"id,omitempty"`
	Image                *string              `json:"image,omitempty"`
	Inspirations         *[]Inspiration       `json:"inspirations,omitempty"`
	LastUpdated          *string              `json:"lastUpdated,omitempty"`
	Lists                *[]ListBaseRecord    `json:"lists,omitempty"`
	Name                 *string              `json:"name,omitempty"`
	NameTranslations     *[]string            `json:"nameTranslations,omitempty"`
	OriginalCountry      *string              `json:"originalCountry,omitempty"`
	OriginalLanguage     *string              `json:"originalLanguage,omitempty"`
	OverviewTranslations *[]string            `json:"overviewTranslations,omitempty"`
	ProductionCountries  *[]ProductionCountry `json:"production_countries,omitempty"`
	Releases             *[]Release           `json:"releases,omitempty"`
	RemoteIDs            *[]RemoteID          `json:"remoteIds,omitempty"`
	Runtime              *int                 `json:"runtime,omitempty"`
	Score                *float64             `json:"score,omitempty"`
	Slug                 *string              `json:"slug,omitempty"`
	SpokenLanguages      *[]string            `json:"spoken_languages,omitempty"`

	// Status status record
	Status            *Status             `json:"status,omitempty"`
	Studios           *[]StudioBaseRecord `json:"studios,omitempty"`
	SubtitleLanguages *[]string           `json:"subtitleLanguages,omitempty"`
	TagOptions        *[]TagOption        `json:"tagOptions,omitempty"`
	Trailers          *[]Trailer          `json:"trailers,omitempty"`

	// Translations translation extended record
	Translations *TranslationExtended `json:"translations,omitempty"`
	Year         *string              `json:"year,omitempty"`
}

// ParentCompany A parent company record
type ParentCompany struct {
	Id   *int    `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`

	// Relation A company relationship
	Relation *CompanyRelationShip `json:"relation,omitempty"`
}

// PeopleBaseRecord base people record
type PeopleBaseRecord struct {
	Aliases              *[]Alias  `json:"aliases,omitempty"`
	ID                   *int64    `json:"id,omitempty"`
	Image                *string   `json:"image,omitempty"`
	LastUpdated          *string   `json:"lastUpdated,omitempty"`
	Name                 *string   `json:"name,omitempty"`
	NameTranslations     *[]string `json:"nameTranslations,omitempty"`
	OverviewTranslations *[]string `json:"overviewTranslations,omitempty"`
	Score                *int64    `json:"score,omitempty"`
}

// PeopleExtendedRecord extended people record
type PeopleExtendedRecord struct {
	Aliases              *[]Alias           `json:"aliases,omitempty"`
	Awards               *[]AwardBaseRecord `json:"awards,omitempty"`
	Biographies          *[]Biography       `json:"biographies,omitempty"`
	Birth                *string            `json:"birth,omitempty"`
	BirthPlace           *string            `json:"birthPlace,omitempty"`
	Characters           *[]Character       `json:"characters,omitempty"`
	Death                *string            `json:"death,omitempty"`
	Gender               *int               `json:"gender,omitempty"`
	ID                   *int64             `json:"id,omitempty"`
	Image                *string            `json:"image,omitempty"`
	LastUpdated          *string            `json:"lastUpdated,omitempty"`
	Name                 *string            `json:"name,omitempty"`
	NameTranslations     *[]string          `json:"nameTranslations,omitempty"`
	OverviewTranslations *[]string          `json:"overviewTranslations,omitempty"`
	Races                *[]Race            `json:"races,omitempty"`
	RemoteIDs            *[]RemoteID        `json:"remoteIds,omitempty"`
	Score                *int64             `json:"score,omitempty"`
	Slug                 *string            `json:"slug,omitempty"`
	TagOptions           *[]TagOption       `json:"tagOptions,omitempty"`

	// Translations translation extended record
	Translations *TranslationExtended `json:"translations,omitempty"`
}

// PeopleType people type record
type PeopleType struct {
	ID   *int64  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// ProductionCountry Production country record
type ProductionCountry struct {
	Country *string `json:"country,omitempty"`
	ID      *int64  `json:"id,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// Race race record
type Race = map[string]interface{}

// RecordInfo base record info
type RecordInfo struct {
	Image *string `json:"image,omitempty"`
	Name  *string `json:"name,omitempty"`
	Year  *string `json:"year,omitempty"`
}

// Release release record
type Release struct {
	Country *string `json:"country,omitempty"`
	Date    *string `json:"date,omitempty"`
	Detail  *string `json:"detail,omitempty"`
}

// RemoteID remote id record
type RemoteID struct {
	ID         *string `json:"id,omitempty"`
	SourceName *string `json:"sourceName,omitempty"`
	Type       *int64  `json:"type,omitempty"`
}

// SearchByRemoteIdResult search by remote reuslt is a base record for a movie, series, people, season or company search result
type SearchByRemoteIdResult struct {
	// Company A company record
	Company *Company `json:"company,omitempty"`

	// Episode base episode record
	Episode *EpisodeBaseRecord `json:"episode,omitempty"`

	// Movie base movie record
	Movie *MovieBaseRecord `json:"movie,omitempty"`

	// People base people record
	People *PeopleBaseRecord `json:"people,omitempty"`

	// Series The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
	Series *SeriesBaseRecord `json:"series,omitempty"`
}

// SearchResult search result
type SearchResult struct {
	Aliases              *[]string            `json:"aliases,omitempty"`
	Companies            *[]string            `json:"companies,omitempty"`
	CompanyType          *string              `json:"companyType,omitempty"`
	Country              *string              `json:"country,omitempty"`
	Director             *string              `json:"director,omitempty"`
	FirstAirTime         *string              `json:"first_air_time,omitempty"`
	Genres               *[]string            `json:"genres,omitempty"`
	Id                   *string              `json:"id,omitempty"`
	ImageUrl             *string              `json:"image_url,omitempty"`
	IsOfficial           *bool                `json:"is_official,omitempty"`
	Name                 *string              `json:"name,omitempty"`
	NameTranslated       *string              `json:"name_translated,omitempty"`
	Network              *string              `json:"network,omitempty"`
	ObjectID             *string              `json:"objectID,omitempty"`
	OfficialList         *string              `json:"officialList,omitempty"`
	Overview             *string              `json:"overview,omitempty"`
	OverviewTranslated   *[]string            `json:"overview_translated,omitempty"`
	// Overviews            *[]TranslationSimple `json:"overviews,omitempty"` // TODO: fix this7
	Poster               *string              `json:"poster,omitempty"`
	Posters              *[]string            `json:"posters,omitempty"`
	PrimaryLanguage      *string              `json:"primary_language,omitempty"`
	RemoteIDs            *[]RemoteID          `json:"remote_ids,omitempty"`
	Slug                 *string              `json:"slug,omitempty"`
	Status               *string              `json:"status,omitempty"`
	Studios              *[]string            `json:"studios,omitempty"`
	Thumbnail            *string              `json:"thumbnail,omitempty"`
	Title                *string              `json:"title,omitempty"`
	// Translations         *[]TranslationSimple `json:"translations,omitempty"` // TODO: fix this
	TranslationsWithLang *[]string            `json:"translationsWithLang,omitempty"`
	TvdbId               *string              `json:"tvdb_id,omitempty"`
	Type                 *string              `json:"type,omitempty"`
	Year                 *string              `json:"year,omitempty"`
}

// SeasonBaseRecord season genre record
type SeasonBaseRecord struct {
	// Companies Companies by type record
	Companies            *Companies `json:"companies,omitempty"`
	Id                   *int       `json:"id,omitempty"`
	Image                *string    `json:"image,omitempty"`
	ImageType            *int       `json:"imageType,omitempty"`
	LastUpdated          *string    `json:"lastUpdated,omitempty"`
	Name                 *string    `json:"name,omitempty"`
	NameTranslations     *[]string  `json:"nameTranslations,omitempty"`
	Number               *int64     `json:"number,omitempty"`
	OverviewTranslations *[]string  `json:"overviewTranslations,omitempty"`
	SeriesID             *int64     `json:"seriesId,omitempty"`

	// Type season type record
	Type *SeasonType `json:"type,omitempty"`
	Year *string     `json:"year,omitempty"`
}

// SeasonExtendedRecord extended season record
type SeasonExtendedRecord struct {
	Artwork *[]ArtworkBaseRecord `json:"artwork,omitempty"`

	// Companies Companies by type record
	Companies            *Companies           `json:"companies,omitempty"`
	Episodes             *[]EpisodeBaseRecord `json:"episodes,omitempty"`
	Id                   *int                 `json:"id,omitempty"`
	Image                *string              `json:"image,omitempty"`
	ImageType            *int                 `json:"imageType,omitempty"`
	LastUpdated          *string              `json:"lastUpdated,omitempty"`
	Name                 *string              `json:"name,omitempty"`
	NameTranslations     *[]string            `json:"nameTranslations,omitempty"`
	Number               *int64               `json:"number,omitempty"`
	OverviewTranslations *[]string            `json:"overviewTranslations,omitempty"`
	SeriesID             *int64               `json:"seriesId,omitempty"`
	TagOptions           *[]TagOption         `json:"tagOptions,omitempty"`
	Trailers             *[]Trailer           `json:"trailers,omitempty"`
	Translations         *[]Translation       `json:"translations,omitempty"`

	// Type season type record
	Type *SeasonType `json:"type,omitempty"`
	Year *string     `json:"year,omitempty"`
}

// SeasonType season type record
type SeasonType struct {
	AlernateName *string `json:"alternateName,omitempty"`
	ID   *int64  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
	Type *string `json:"type,omitempty"`
}

// SeriesAirsDays A series airs day record
type SeriesAirsDays struct {
	Friday    *bool `json:"friday,omitempty"`
	Monday    *bool `json:"monday,omitempty"`
	Saturday  *bool `json:"saturday,omitempty"`
	Sunday    *bool `json:"sunday,omitempty"`
	Thursday  *bool `json:"thursday,omitempty"`
	Tuesday   *bool `json:"tuesday,omitempty"`
	Wednesday *bool `json:"wednesday,omitempty"`
}

// SeriesBaseRecord The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
type SeriesBaseRecord struct {
	Aliases              *[]Alias             `json:"aliases,omitempty"`
	AverageRuntime       *int                 `json:"averageRuntime,omitempty"`
	Country              *string              `json:"country,omitempty"`
	DefaultSeasonType    *int64               `json:"defaultSeasonType,omitempty"`
	Episodes             *[]EpisodeBaseRecord `json:"episodes,omitempty"`
	FirstAired           *string              `json:"firstAired,omitempty"`
	Id                   *int                 `json:"id,omitempty"`
	Image                *string              `json:"image,omitempty"`
	IsOrderRandomized    *bool                `json:"isOrderRandomized,omitempty"`
	LastAired            *string              `json:"lastAired,omitempty"`
	LastUpdated          *string              `json:"lastUpdated,omitempty"`
	Name                 *string              `json:"name,omitempty"`
	NameTranslations     *[]string            `json:"nameTranslations,omitempty"`
	NextAired            *string              `json:"nextAired,omitempty"`
	OriginalCountry      *string              `json:"originalCountry,omitempty"`
	OriginalLanguage     *string              `json:"originalLanguage,omitempty"`
	OverviewTranslations *[]string            `json:"overviewTranslations,omitempty"`
	Score                *float64             `json:"score,omitempty"`
	Slug                 *string              `json:"slug,omitempty"`

	// Status status record
	Status *Status `json:"status,omitempty"`
	Year   *string `json:"year,omitempty"`
}

// SeriesExtendedRecord The extended record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
type SeriesExtendedRecord struct {
	Abbreviation *string `json:"abbreviation,omitempty"`

	// AirsDays A series airs day record
	AirsDays          *SeriesAirsDays          `json:"airsDays,omitempty"`
	AirsTime          *string                  `json:"airsTime,omitempty"`
	Aliases           *[]Alias                 `json:"aliases,omitempty"`
	Artworks          *[]ArtworkExtendedRecord `json:"artworks,omitempty"`
	AverageRuntime    *int                     `json:"averageRuntime,omitempty"`
	Characters        *[]Character             `json:"characters,omitempty"`
	Companies         *[]Company               `json:"companies,omitempty"`
	ContentRatings    *[]ContentRating         `json:"contentRatings,omitempty"`
	Country           *string                  `json:"country,omitempty"`
	DefaultSeasonType *int64                   `json:"defaultSeasonType,omitempty"`
	Episodes          *[]EpisodeBaseRecord     `json:"episodes,omitempty"`
	FirstAired        *string                  `json:"firstAired,omitempty"`
	Genres            *[]GenreBaseRecord       `json:"genres,omitempty"`
	Id                *int                     `json:"id,omitempty"`
	Image             *string                  `json:"image,omitempty"`
	IsOrderRandomized *bool                    `json:"isOrderRandomized,omitempty"`
	LastAired         *string                  `json:"lastAired,omitempty"`
	LastUpdated       *string                  `json:"lastUpdated,omitempty"`

	// LatestNetwork A company record
	LatestNetwork    *Company     `json:"latestNetwork,omitempty"`
	Lists            *interface{} `json:"lists,omitempty"`
	Name             *string      `json:"name,omitempty"`
	NameTranslations *[]string    `json:"nameTranslations,omitempty"`
	NextAired        *string      `json:"nextAired,omitempty"`
	OriginalCountry  *string      `json:"originalCountry,omitempty"`
	OriginalLanguage *string      `json:"originalLanguage,omitempty"`

	// OriginalNetwork A company record
	OriginalNetwork      *Company            `json:"originalNetwork,omitempty"`
	Overview             *string             `json:"overview,omitempty"`
	OverviewTranslations *[]string           `json:"overviewTranslations,omitempty"`
	RemoteIDs            *[]RemoteID         `json:"remoteIds,omitempty"`
	Score                *float64            `json:"score,omitempty"`
	SeasonTypes              *[]SeasonType       `json:"seasonTypes,omitempty"`
	Seasons              *[]SeasonBaseRecord `json:"seasons,omitempty"`
	Slug                 *string             `json:"slug,omitempty"`

	// Status status record
	Status     *Status      `json:"status,omitempty"`
	TagOptions *[]TagOption `json:"tags,omitempty"`
	Trailers   *[]Trailer   `json:"trailers,omitempty"`

	// Translations translation extended record
	Translations *TranslationExtended `json:"translations,omitempty"`
	Year         *string              `json:"year,omitempty"`
}

// SourceType source type record
type SourceType struct {
	ID      *int64  `json:"id,omitempty"`
	Name    *string `json:"name,omitempty"`
	Postfix *string `json:"postfix,omitempty"`
	Prefix  *string `json:"prefix,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Sort    *int64  `json:"sort,omitempty"`
}

// Status status record
type Status struct {
	ID          *int64  `json:"id,omitempty"`
	KeepUpdated *bool   `json:"keepUpdated,omitempty"`
	Name        *string `json:"name,omitempty"`
	RecordType  *string `json:"recordType,omitempty"`
}

// StudioBaseRecord studio record
type StudioBaseRecord struct {
	ID           *int64  `json:"id,omitempty"`
	Name         *string `json:"name,omitempty"`
	ParentStudio *int    `json:"parentStudio,omitempty"`
}

// TagOption tag option record
type TagOption struct {
	HelpText *string `json:"helpText,omitempty"`
	ID       *int64  `json:"id,omitempty"`
	Name     *string `json:"name,omitempty"`
	Tag      *int64  `json:"tag,omitempty"`
	TagName  *string `json:"tagName,omitempty"`
}

// Trailer trailer record
type Trailer struct {
	ID       *int64  `json:"id,omitempty"`
	Language *string `json:"language,omitempty"`
	Name     *string `json:"name,omitempty"`
	Runtime  *int    `json:"runtime,omitempty"`
	Url      *string `json:"url,omitempty"`
}

// Translation translation record
type Translation struct {
	Aliases   *[]string `json:"aliases,omitempty"`
	IsAlias   *bool     `json:"isAlias,omitempty"`
	IsPrimary *bool     `json:"isPrimary,omitempty"`
	Language  *string   `json:"language,omitempty"`
	Name      *string   `json:"name,omitempty"`
	Overview  *string   `json:"overview,omitempty"`

	// Tagline Only populated for movie translations.  We disallow taglines without a title.
	Tagline *string `json:"tagline,omitempty"`
}

// TranslationExtended translation extended record
type TranslationExtended struct {
	Alias                *[]string      `json:"alias,omitempty"`
	NameTranslations     *[]Translation `json:"nameTranslations,omitempty"`
	OverviewTranslations *[]Translation `json:"overviewTranslations,omitempty"`
}

// TranslationSimple translation simple record
type TranslationSimple struct {
	Language *string `json:"language,omitempty"`
}

// UserInfo User info record
type UserInfo struct {
	Id       *int    `json:"id,omitempty"`
	Language *string `json:"language,omitempty"`
	Name     *string `json:"name,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// GetAllCompaniesParams defines parameters for GetAllCompanies.
type GetAllCompaniesParams struct {
	// Page name
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`
}

// GetAllEpisodesParams defines parameters for GetAllEpisodes.
type GetAllEpisodesParams struct {
	// Page page number
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`
}

// GetEpisodeExtendedParams defines parameters for GetEpisodeExtended.
type GetEpisodeExtendedParams struct {
	// Meta meta
	Meta *GetEpisodeExtendedParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
}

// GetEpisodeExtendedParamsMeta defines parameters for GetEpisodeExtended.
type GetEpisodeExtendedParamsMeta string

// GetAllListsParams defines parameters for GetAllLists.
type GetAllListsParams struct {
	// Page page number
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`
}

// PostLoginJSONBody defines parameters for PostLogin.
type PostLoginJSONBody struct {
	Apikey string  `json:"apikey"`
	Pin    *string `json:"pin,omitempty"`
}

// GetAllMovieParams defines parameters for GetAllMovie.
type GetAllMovieParams struct {
	// Page page number
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`
}

// GetMoviesFilterParams defines parameters for GetMoviesFilter.
type GetMoviesFilterParams struct {
	// Company production company
	Company *float32 `form:"company,omitempty" json:"company,omitempty"`

	// ContentRating content rating id base on a country
	ContentRating *float32 `form:"contentRating,omitempty" json:"contentRating,omitempty"`

	// Country country of origin
	Country string `form:"country" json:"country"`

	// Genre genre
	Genre *GetMoviesFilterParamsGenre `form:"genre,omitempty" json:"genre,omitempty"`

	// Lang original language
	Lang string `form:"lang" json:"lang"`

	// Sort sort by results
	Sort *GetMoviesFilterParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Status status
	Status *GetMoviesFilterParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Year release year
	Year *float32 `form:"year,omitempty" json:"year,omitempty"`
}

// GetMoviesFilterParamsGenre defines parameters for GetMoviesFilter.
type GetMoviesFilterParamsGenre float32

// GetMoviesFilterParamsSort defines parameters for GetMoviesFilter.
type GetMoviesFilterParamsSort string

// GetMoviesFilterParamsStatus defines parameters for GetMoviesFilter.
type GetMoviesFilterParamsStatus float32

// GetMovieExtendedParams defines parameters for GetMovieExtended.
type GetMovieExtendedParams struct {
	// Meta meta
	Meta *GetMovieExtendedParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Short reduce the payload and returns the short version of this record without characters, artworks and trailers.
	Short *GetMovieExtendedParamsShort `form:"short,omitempty" json:"short,omitempty"`
}

// GetMovieExtendedParamsMeta defines parameters for GetMovieExtended.
type GetMovieExtendedParamsMeta string

// GetMovieExtendedParamsShort defines parameters for GetMovieExtended.
type GetMovieExtendedParamsShort bool

// GetAllPeopleParams defines parameters for GetAllPeople.
type GetAllPeopleParams struct {
	// Page page number
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`
}

// GetPeopleExtendedParams defines parameters for GetPeopleExtended.
type GetPeopleExtendedParams struct {
	// Meta meta
	Meta *GetPeopleExtendedParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
}

// GetPeopleExtendedParamsMeta defines parameters for GetPeopleExtended.
type GetPeopleExtendedParamsMeta string

// GetSearchResultsParams defines parameters for GetSearchResults.
type GetSearchResultsParams struct {
	// Query The primary search string, which can include the main title for a record including all translations and aliases.
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Q Alias of the "query" parameter.  Recommend using query instead as this field will eventually be deprecated.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Type Restrict results to a specific entity type.  Can be movie, series, person, or company.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Year Restrict results to a specific year. Currently only used for series and movies.
	Year *float32 `form:"year,omitempty" json:"year,omitempty"`

	// Company Restrict results to a specific company (original network, production company, studio, etc).  As an example, "The Walking Dead" would have companies of "AMC", "AMC+", and "Disney+".
	Company *string `form:"company,omitempty" json:"company,omitempty"`

	// Country Restrict results to a specific country of origin. Should contain a 3 character country code. Currently only used for series and movies.
	Country *string `form:"country,omitempty" json:"country,omitempty"`

	// Director Restrict results to a specific director.  Generally only used for movies.  Should include the full name of the director, such as "Steven Spielberg".
	Director *string `form:"director,omitempty" json:"director,omitempty"`

	// Language Restrict results to a specific primary language.  Should include the 3 character language code.  Currently only used for series and movies.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// PrimaryType Restrict results to a specific type of company.  Should include the full name of the type of company, such as "Production Company".  Only used for companies.
	PrimaryType *string `form:"primaryType,omitempty" json:"primaryType,omitempty"`

	// Network Restrict results to a specific network.  Used for TV and TV movies, and functions the same as the company parameter with more specificity.
	Network *string `form:"network,omitempty" json:"network,omitempty"`

	// RemoteId Search for a specific remote id.  Allows searching for an IMDB or EIDR id, for example.
	RemoteId *string `form:"remote_id,omitempty" json:"remote_id,omitempty"`

	// Offset Offset results.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit results.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAllSeasonsParams defines parameters for GetAllSeasons.
type GetAllSeasonsParams struct {
	// Page page number
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`
}

// GetAllSeriesParams defines parameters for GetAllSeries.
type GetAllSeriesParams struct {
	// Page page number
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`
}

// GetSeriesFilterParams defines parameters for GetSeriesFilter.
type GetSeriesFilterParams struct {
	// Company production company
	Company *float32 `form:"company,omitempty" json:"company,omitempty"`

	// ContentRating content rating id base on a country
	ContentRating *float32 `form:"contentRating,omitempty" json:"contentRating,omitempty"`

	// Country country of origin
	Country string `form:"country" json:"country"`

	// Genre Genre id. This id can be found using **/genres** endpoint.
	Genre *GetSeriesFilterParamsGenre `form:"genre,omitempty" json:"genre,omitempty"`

	// Lang original language
	Lang string `form:"lang" json:"lang"`

	// Sort sort by results
	Sort *GetSeriesFilterParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// SortType sort type ascending or descending
	SortType *GetSeriesFilterParamsSortType `form:"sortType,omitempty" json:"sortType,omitempty"`

	// Status status
	Status *GetSeriesFilterParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Year release year
	Year *float32 `form:"year,omitempty" json:"year,omitempty"`
}

// GetSeriesFilterParamsGenre defines parameters for GetSeriesFilter.
type GetSeriesFilterParamsGenre float32

// GetSeriesFilterParamsSort defines parameters for GetSeriesFilter.
type GetSeriesFilterParamsSort string

// GetSeriesFilterParamsSortType defines parameters for GetSeriesFilter.
type GetSeriesFilterParamsSortType string

// GetSeriesFilterParamsStatus defines parameters for GetSeriesFilter.
type GetSeriesFilterParamsStatus float32

// GetSeriesArtworksParams defines parameters for GetSeriesArtworks.
type GetSeriesArtworksParams struct {
	// Lang lang
	Lang *string `form:"lang,omitempty" json:"lang,omitempty"`

	// Type type
	Type *int `form:"type,omitempty" json:"type,omitempty"`
}

// GetSeriesEpisodesParams defines parameters for GetSeriesEpisodes.
type GetSeriesEpisodesParams struct {
	Page          int  `form:"page" json:"page"`
	Season        *int `form:"season,omitempty" json:"season,omitempty"`
	EpisodeNumber *int `form:"episodeNumber,omitempty" json:"episodeNumber,omitempty"`

	// AirDate airDate of the episode, format is yyyy-mm-dd
	AirDate *string `form:"airDate,omitempty" json:"airDate,omitempty"`
}

// GetSeriesSeasonEpisodesTranslatedParams defines parameters for GetSeriesSeasonEpisodesTranslated.
type GetSeriesSeasonEpisodesTranslatedParams struct {
	Page int `form:"page" json:"page"`
}

// GetSeriesExtendedParams defines parameters for GetSeriesExtended.
type GetSeriesExtendedParams struct {
	// Meta meta
	Meta *GetSeriesExtendedParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Short reduce the payload and returns the short version of this record without characters and artworks
	Short *GetSeriesExtendedParamsShort `form:"short,omitempty" json:"short,omitempty"`
}

// GetSeriesExtendedParamsMeta defines parameters for GetSeriesExtended.
type GetSeriesExtendedParamsMeta string

// GetSeriesExtendedParamsShort defines parameters for GetSeriesExtended.
type GetSeriesExtendedParamsShort bool

// UpdatesParams defines parameters for Updates.
type UpdatesParams struct {
	Since  float32              `form:"since" json:"since"`
	Type   *UpdatesParamsType   `form:"type,omitempty" json:"type,omitempty"`
	Action *UpdatesParamsAction `form:"action,omitempty" json:"action,omitempty"`

	// Page name
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`
}

// UpdatesParamsType defines parameters for Updates.
type UpdatesParamsType string

// UpdatesParamsAction defines parameters for Updates.
type UpdatesParamsAction string

// PostLoginJSONRequestBody defines body for PostLogin for application/json ContentType.
type PostLoginJSONRequestBody PostLoginJSONBody

// CreateUserFavoritesJSONRequestBody defines body for CreateUserFavorites for application/json ContentType.
type CreateUserFavoritesJSONRequestBody = FavoriteRecord

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func newClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllArtworkStatuses request
	GetAllArtworkStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllArtworkTypes request
	GetAllArtworkTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArtworkBase request
	GetArtworkBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArtworkExtended request
	GetArtworkExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAwards request
	GetAllAwards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAwardCategory request
	GetAwardCategory(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAwardCategoryExtended request
	GetAwardCategoryExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAward request
	GetAward(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAwardExtended request
	GetAwardExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharacterBase request
	GetCharacterBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCompanies request
	GetAllCompanies(ctx context.Context, params *GetAllCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompanyTypes request
	GetCompanyTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompany request
	GetCompany(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllContentRatings request
	GetAllContentRatings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCountries request
	GetAllCountries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntityTypes request
	GetEntityTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllEpisodes request
	GetAllEpisodes(ctx context.Context, params *GetAllEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEpisodeBase request
	GetEpisodeBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEpisodeExtended request
	GetEpisodeExtended(ctx context.Context, id float32, params *GetEpisodeExtendedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEpisodeTranslation request
	GetEpisodeTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllGenders request
	GetAllGenders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllGenres request
	GetAllGenres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGenreBase request
	GetGenreBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllInspirationTypes request
	GetAllInspirationTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLanguages request
	GetAllLanguages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLists request
	GetAllLists(ctx context.Context, params *GetAllListsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListBySlug request
	GetListBySlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetList request
	GetList(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListExtended request
	GetListExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListTranslation request
	GetListTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLoginWithBody request with any body
	PostLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLogin(ctx context.Context, body PostLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllMovie request
	GetAllMovie(ctx context.Context, params *GetAllMovieParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMoviesFilter request
	GetMoviesFilter(ctx context.Context, params *GetMoviesFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMovieBaseBySlug request
	GetMovieBaseBySlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllMovieStatuses request
	GetAllMovieStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMovieBase request
	GetMovieBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMovieExtended request
	GetMovieExtended(ctx context.Context, id float32, params *GetMovieExtendedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMovieTranslation request
	GetMovieTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllPeople request
	GetAllPeople(ctx context.Context, params *GetAllPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllPeopleTypes request
	GetAllPeopleTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeopleBase request
	GetPeopleBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeopleExtended request
	GetPeopleExtended(ctx context.Context, id float32, params *GetPeopleExtendedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeopleTranslation request
	GetPeopleTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResults request
	GetSearchResults(ctx context.Context, params *GetSearchResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResultsByRemoteId request
	GetSearchResultsByRemoteId(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSeasons request
	GetAllSeasons(ctx context.Context, params *GetAllSeasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeasonTypes request
	GetSeasonTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeasonBase request
	GetSeasonBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeasonExtended request
	GetSeasonExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeasonTranslation request
	GetSeasonTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSeries request
	GetAllSeries(ctx context.Context, params *GetAllSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesFilter request
	GetSeriesFilter(ctx context.Context, params *GetSeriesFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesBaseBySlug request
	GetSeriesBaseBySlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSeriesStatuses request
	GetAllSeriesStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesBase request
	GetSeriesBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesArtworks request
	GetSeriesArtworks(ctx context.Context, id float32, params *GetSeriesArtworksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesEpisodes request
	GetSeriesEpisodes(ctx context.Context, id float32, seasonType string, params *GetSeriesEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesSeasonEpisodesTranslated request
	GetSeriesSeasonEpisodesTranslated(ctx context.Context, id float32, seasonType string, lang string, params *GetSeriesSeasonEpisodesTranslatedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesExtended request
	GetSeriesExtended(ctx context.Context, id float32, params *GetSeriesExtendedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesNextAired request
	GetSeriesNextAired(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesTranslation request
	GetSeriesTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSourceTypes request
	GetAllSourceTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Updates request
	Updates(ctx context.Context, params *UpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserInfo request
	GetUserInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFavorites request
	GetUserFavorites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserFavoritesWithBody request with any body
	CreateUserFavoritesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserFavorites(ctx context.Context, body CreateUserFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserInfoById request
	GetUserInfoById(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllArtworkStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllArtworkStatusesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllArtworkTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllArtworkTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArtworkBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArtworkBaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArtworkExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArtworkExtendedRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAwards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAwardsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAwardCategory(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAwardCategoryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAwardCategoryExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAwardCategoryExtendedRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAward(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAwardRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAwardExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAwardExtendedRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharacterBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharacterBaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCompanies(ctx context.Context, params *GetAllCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCompaniesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompanyTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompany(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllContentRatings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllContentRatingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCountries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCountriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntityTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllEpisodes(ctx context.Context, params *GetAllEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllEpisodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEpisodeBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEpisodeBaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEpisodeExtended(ctx context.Context, id float32, params *GetEpisodeExtendedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEpisodeExtendedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEpisodeTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEpisodeTranslationRequest(c.Server, id, language)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllGenders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllGendersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllGenres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllGenresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGenreBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGenreBaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllInspirationTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllInspirationTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLanguages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLanguagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLists(ctx context.Context, params *GetAllListsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllListsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListBySlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListBySlugRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetList(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListExtendedRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListTranslationRequest(c.Server, id, language)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLogin(ctx context.Context, body PostLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllMovie(ctx context.Context, params *GetAllMovieParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllMovieRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMoviesFilter(ctx context.Context, params *GetMoviesFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMoviesFilterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMovieBaseBySlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMovieBaseBySlugRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllMovieStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllMovieStatusesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMovieBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMovieBaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMovieExtended(ctx context.Context, id float32, params *GetMovieExtendedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMovieExtendedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMovieTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMovieTranslationRequest(c.Server, id, language)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllPeople(ctx context.Context, params *GetAllPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllPeopleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllPeopleTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllPeopleTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeopleBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeopleBaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeopleExtended(ctx context.Context, id float32, params *GetPeopleExtendedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeopleExtendedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeopleTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeopleTranslationRequest(c.Server, id, language)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResults(ctx context.Context, params *GetSearchResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResultsByRemoteId(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultsByRemoteIdRequest(c.Server, remoteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSeasons(ctx context.Context, params *GetAllSeasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSeasonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeasonTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeasonBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonBaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeasonExtended(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonExtendedRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeasonTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonTranslationRequest(c.Server, id, language)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSeries(ctx context.Context, params *GetAllSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSeriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesFilter(ctx context.Context, params *GetSeriesFilterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesFilterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesBaseBySlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesBaseBySlugRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSeriesStatuses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSeriesStatusesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesBase(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesBaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesArtworks(ctx context.Context, id float32, params *GetSeriesArtworksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesArtworksRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesEpisodes(ctx context.Context, id float32, seasonType string, params *GetSeriesEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesEpisodesRequest(c.Server, id, seasonType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesSeasonEpisodesTranslated(ctx context.Context, id float32, seasonType string, lang string, params *GetSeriesSeasonEpisodesTranslatedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesSeasonEpisodesTranslatedRequest(c.Server, id, seasonType, lang, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesExtended(ctx context.Context, id float32, params *GetSeriesExtendedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesExtendedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesNextAired(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesNextAiredRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesTranslation(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesTranslationRequest(c.Server, id, language)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSourceTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSourceTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Updates(ctx context.Context, params *UpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFavorites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFavoritesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserFavoritesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserFavoritesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserFavorites(ctx context.Context, body CreateUserFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserFavoritesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserInfoById(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserInfoByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllArtworkStatusesRequest generates requests for GetAllArtworkStatuses
func NewGetAllArtworkStatusesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artwork/statuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllArtworkTypesRequest generates requests for GetAllArtworkTypes
func NewGetAllArtworkTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artwork/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArtworkBaseRequest generates requests for GetArtworkBase
func NewGetArtworkBaseRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artwork/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArtworkExtendedRequest generates requests for GetArtworkExtended
func NewGetArtworkExtendedRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artwork/%s/extended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllAwardsRequest generates requests for GetAllAwards
func NewGetAllAwardsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/awards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAwardCategoryRequest generates requests for GetAwardCategory
func NewGetAwardCategoryRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/awards/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAwardCategoryExtendedRequest generates requests for GetAwardCategoryExtended
func NewGetAwardCategoryExtendedRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/awards/categories/%s/extended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAwardRequest generates requests for GetAward
func NewGetAwardRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/awards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAwardExtendedRequest generates requests for GetAwardExtended
func NewGetAwardExtendedRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/awards/%s/extended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharacterBaseRequest generates requests for GetCharacterBase
func NewGetCharacterBaseRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/characters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllCompaniesRequest generates requests for GetAllCompanies
func NewGetAllCompaniesRequest(server string, params *GetAllCompaniesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompanyTypesRequest generates requests for GetCompanyTypes
func NewGetCompanyTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompanyRequest generates requests for GetCompany
func NewGetCompanyRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllContentRatingsRequest generates requests for GetAllContentRatings
func NewGetAllContentRatingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/content/ratings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllCountriesRequest generates requests for GetAllCountries
func NewGetAllCountriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/countries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntityTypesRequest generates requests for GetEntityTypes
func NewGetEntityTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllEpisodesRequest generates requests for GetAllEpisodes
func NewGetAllEpisodesRequest(server string, params *GetAllEpisodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEpisodeBaseRequest generates requests for GetEpisodeBase
func NewGetEpisodeBaseRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEpisodeExtendedRequest generates requests for GetEpisodeExtended
func NewGetEpisodeExtendedRequest(server string, id float32, params *GetEpisodeExtendedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes/%s/extended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEpisodeTranslationRequest generates requests for GetEpisodeTranslation
func NewGetEpisodeTranslationRequest(server string, id float32, language string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes/%s/translations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllGendersRequest generates requests for GetAllGenders
func NewGetAllGendersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllGenresRequest generates requests for GetAllGenres
func NewGetAllGenresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genres")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGenreBaseRequest generates requests for GetGenreBase
func NewGetGenreBaseRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genres/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllInspirationTypesRequest generates requests for GetAllInspirationTypes
func NewGetAllInspirationTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inspiration/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllLanguagesRequest generates requests for GetAllLanguages
func NewGetAllLanguagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/languages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllListsRequest generates requests for GetAllLists
func NewGetAllListsRequest(server string, params *GetAllListsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListBySlugRequest generates requests for GetListBySlug
func NewGetListBySlugRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lists/slug/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListRequest generates requests for GetList
func NewGetListRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListExtendedRequest generates requests for GetListExtended
func NewGetListExtendedRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lists/%s/extended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListTranslationRequest generates requests for GetListTranslation
func NewGetListTranslationRequest(server string, id float32, language string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lists/%s/translations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLoginRequest calls the generic PostLogin builder with application/json body
func NewPostLoginRequest(server string, body PostLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLoginRequestWithBody generates requests for PostLogin with any type of body
func NewPostLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllMovieRequest generates requests for GetAllMovie
func NewGetAllMovieRequest(server string, params *GetAllMovieParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/movies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMoviesFilterRequest generates requests for GetMoviesFilter
func NewGetMoviesFilterRequest(server string, params *GetMoviesFilterParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/movies/filter")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Company != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "company", runtime.ParamLocationQuery, *params.Company); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentRating", runtime.ParamLocationQuery, *params.ContentRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, params.Country); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Genre != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genre", runtime.ParamLocationQuery, *params.Genre); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, params.Lang); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Year != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "year", runtime.ParamLocationQuery, *params.Year); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMovieBaseBySlugRequest generates requests for GetMovieBaseBySlug
func NewGetMovieBaseBySlugRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/movies/slug/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllMovieStatusesRequest generates requests for GetAllMovieStatuses
func NewGetAllMovieStatusesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/movies/statuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMovieBaseRequest generates requests for GetMovieBase
func NewGetMovieBaseRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/movies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMovieExtendedRequest generates requests for GetMovieExtended
func NewGetMovieExtendedRequest(server string, id float32, params *GetMovieExtendedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/movies/%s/extended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Short != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short", runtime.ParamLocationQuery, *params.Short); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMovieTranslationRequest generates requests for GetMovieTranslation
func NewGetMovieTranslationRequest(server string, id float32, language string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/movies/%s/translations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllPeopleRequest generates requests for GetAllPeople
func NewGetAllPeopleRequest(server string, params *GetAllPeopleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllPeopleTypesRequest generates requests for GetAllPeopleTypes
func NewGetAllPeopleTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeopleBaseRequest generates requests for GetPeopleBase
func NewGetPeopleBaseRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeopleExtendedRequest generates requests for GetPeopleExtended
func NewGetPeopleExtendedRequest(server string, id float32, params *GetPeopleExtendedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/extended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeopleTranslationRequest generates requests for GetPeopleTranslation
func NewGetPeopleTranslationRequest(server string, id float32, language string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/translations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchResultsRequest generates requests for GetSearchResults
func NewGetSearchResultsRequest(server string, params *GetSearchResultsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Year != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "year", runtime.ParamLocationQuery, *params.Year); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Company != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "company", runtime.ParamLocationQuery, *params.Company); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Director != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "director", runtime.ParamLocationQuery, *params.Director); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primaryType", runtime.ParamLocationQuery, *params.PrimaryType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Network != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "network", runtime.ParamLocationQuery, *params.Network); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remote_id", runtime.ParamLocationQuery, *params.RemoteId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchResultsByRemoteIdRequest generates requests for GetSearchResultsByRemoteId
func NewGetSearchResultsByRemoteIdRequest(server string, remoteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "remoteId", runtime.ParamLocationPath, remoteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/remoteid/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSeasonsRequest generates requests for GetAllSeasons
func NewGetAllSeasonsRequest(server string, params *GetAllSeasonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/seasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonTypesRequest generates requests for GetSeasonTypes
func NewGetSeasonTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/seasons/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonBaseRequest generates requests for GetSeasonBase
func NewGetSeasonBaseRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/seasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonExtendedRequest generates requests for GetSeasonExtended
func NewGetSeasonExtendedRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/seasons/%s/extended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonTranslationRequest generates requests for GetSeasonTranslation
func NewGetSeasonTranslationRequest(server string, id float32, language string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/seasons/%s/translations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSeriesRequest generates requests for GetAllSeries
func NewGetAllSeriesRequest(server string, params *GetAllSeriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesFilterRequest generates requests for GetSeriesFilter
func NewGetSeriesFilterRequest(server string, params *GetSeriesFilterParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/filter")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Company != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "company", runtime.ParamLocationQuery, *params.Company); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentRating", runtime.ParamLocationQuery, *params.ContentRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, params.Country); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Genre != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genre", runtime.ParamLocationQuery, *params.Genre); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, params.Lang); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortType", runtime.ParamLocationQuery, *params.SortType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Year != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "year", runtime.ParamLocationQuery, *params.Year); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesBaseBySlugRequest generates requests for GetSeriesBaseBySlug
func NewGetSeriesBaseBySlugRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/slug/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSeriesStatusesRequest generates requests for GetAllSeriesStatuses
func NewGetAllSeriesStatusesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/statuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesBaseRequest generates requests for GetSeriesBase
func NewGetSeriesBaseRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesArtworksRequest generates requests for GetSeriesArtworks
func NewGetSeriesArtworksRequest(server string, id float32, params *GetSeriesArtworksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/%s/artworks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Lang != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lang", runtime.ParamLocationQuery, *params.Lang); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesEpisodesRequest generates requests for GetSeriesEpisodes
func NewGetSeriesEpisodesRequest(server string, id float32, seasonType string, params *GetSeriesEpisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season-type", runtime.ParamLocationPath, seasonType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/%s/episodes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EpisodeNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "episodeNumber", runtime.ParamLocationQuery, *params.EpisodeNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AirDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "airDate", runtime.ParamLocationQuery, *params.AirDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesSeasonEpisodesTranslatedRequest generates requests for GetSeriesSeasonEpisodesTranslated
func NewGetSeriesSeasonEpisodesTranslatedRequest(server string, id float32, seasonType string, lang string, params *GetSeriesSeasonEpisodesTranslatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season-type", runtime.ParamLocationPath, seasonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lang", runtime.ParamLocationPath, lang)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/%s/episodes/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesExtendedRequest generates requests for GetSeriesExtended
func NewGetSeriesExtendedRequest(server string, id float32, params *GetSeriesExtendedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/%s/extended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Short != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "short", runtime.ParamLocationQuery, *params.Short); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesNextAiredRequest generates requests for GetSeriesNextAired
func NewGetSeriesNextAiredRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/%s/nextAired", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesTranslationRequest generates requests for GetSeriesTranslation
func NewGetSeriesTranslationRequest(server string, id float32, language string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/series/%s/translations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSourceTypesRequest generates requests for GetAllSourceTypes
func NewGetAllSourceTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatesRequest generates requests for Updates
func NewUpdatesRequest(server string, params *UpdatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/updates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserInfoRequest generates requests for GetUserInfo
func NewGetUserInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFavoritesRequest generates requests for GetUserFavorites
func NewGetUserFavoritesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/favorites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserFavoritesRequest calls the generic CreateUserFavorites builder with application/json body
func NewCreateUserFavoritesRequest(server string, body CreateUserFavoritesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserFavoritesRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserFavoritesRequestWithBody generates requests for CreateUserFavorites with any type of body
func NewCreateUserFavoritesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/favorites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserInfoByIdRequest generates requests for GetUserInfoById
func NewGetUserInfoByIdRequest(server string, id float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func newClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := newClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllArtworkStatusesWithResponse request
	GetAllArtworkStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllArtworkStatusesResponse, error)

	// GetAllArtworkTypesWithResponse request
	GetAllArtworkTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllArtworkTypesResponse, error)

	// GetArtworkBaseWithResponse request
	GetArtworkBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetArtworkBaseResponse, error)

	// GetArtworkExtendedWithResponse request
	GetArtworkExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetArtworkExtendedResponse, error)

	// GetAllAwardsWithResponse request
	GetAllAwardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllAwardsResponse, error)

	// GetAwardCategoryWithResponse request
	GetAwardCategoryWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetAwardCategoryResponse, error)

	// GetAwardCategoryExtendedWithResponse request
	GetAwardCategoryExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetAwardCategoryExtendedResponse, error)

	// GetAwardWithResponse request
	GetAwardWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetAwardResponse, error)

	// GetAwardExtendedWithResponse request
	GetAwardExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetAwardExtendedResponse, error)

	// GetCharacterBaseWithResponse request
	GetCharacterBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetCharacterBaseResponse, error)

	// GetAllCompaniesWithResponse request
	GetAllCompaniesWithResponse(ctx context.Context, params *GetAllCompaniesParams, reqEditors ...RequestEditorFn) (*GetAllCompaniesResponse, error)

	// GetCompanyTypesWithResponse request
	GetCompanyTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompanyTypesResponse, error)

	// GetCompanyWithResponse request
	GetCompanyWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetCompanyResponse, error)

	// GetAllContentRatingsWithResponse request
	GetAllContentRatingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllContentRatingsResponse, error)

	// GetAllCountriesWithResponse request
	GetAllCountriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCountriesResponse, error)

	// GetEntityTypesWithResponse request
	GetEntityTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEntityTypesResponse, error)

	// GetAllEpisodesWithResponse request
	GetAllEpisodesWithResponse(ctx context.Context, params *GetAllEpisodesParams, reqEditors ...RequestEditorFn) (*GetAllEpisodesResponse, error)

	// GetEpisodeBaseWithResponse request
	GetEpisodeBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetEpisodeBaseResponse, error)

	// GetEpisodeExtendedWithResponse request
	GetEpisodeExtendedWithResponse(ctx context.Context, id float32, params *GetEpisodeExtendedParams, reqEditors ...RequestEditorFn) (*GetEpisodeExtendedResponse, error)

	// GetEpisodeTranslationWithResponse request
	GetEpisodeTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetEpisodeTranslationResponse, error)

	// GetAllGendersWithResponse request
	GetAllGendersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllGendersResponse, error)

	// GetAllGenresWithResponse request
	GetAllGenresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllGenresResponse, error)

	// GetGenreBaseWithResponse request
	GetGenreBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetGenreBaseResponse, error)

	// GetAllInspirationTypesWithResponse request
	GetAllInspirationTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllInspirationTypesResponse, error)

	// GetAllLanguagesWithResponse request
	GetAllLanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllLanguagesResponse, error)

	// GetAllListsWithResponse request
	GetAllListsWithResponse(ctx context.Context, params *GetAllListsParams, reqEditors ...RequestEditorFn) (*GetAllListsResponse, error)

	// GetListBySlugWithResponse request
	GetListBySlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetListBySlugResponse, error)

	// GetListWithResponse request
	GetListWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetListResponse, error)

	// GetListExtendedWithResponse request
	GetListExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetListExtendedResponse, error)

	// GetListTranslationWithResponse request
	GetListTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetListTranslationResponse, error)

	// PostLoginWithBodyWithResponse request with any body
	PostLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLoginResponse, error)

	PostLoginWithResponse(ctx context.Context, body PostLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLoginResponse, error)

	// GetAllMovieWithResponse request
	GetAllMovieWithResponse(ctx context.Context, params *GetAllMovieParams, reqEditors ...RequestEditorFn) (*GetAllMovieResponse, error)

	// GetMoviesFilterWithResponse request
	GetMoviesFilterWithResponse(ctx context.Context, params *GetMoviesFilterParams, reqEditors ...RequestEditorFn) (*GetMoviesFilterResponse, error)

	// GetMovieBaseBySlugWithResponse request
	GetMovieBaseBySlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetMovieBaseBySlugResponse, error)

	// GetAllMovieStatusesWithResponse request
	GetAllMovieStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllMovieStatusesResponse, error)

	// GetMovieBaseWithResponse request
	GetMovieBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetMovieBaseResponse, error)

	// GetMovieExtendedWithResponse request
	GetMovieExtendedWithResponse(ctx context.Context, id float32, params *GetMovieExtendedParams, reqEditors ...RequestEditorFn) (*GetMovieExtendedResponse, error)

	// GetMovieTranslationWithResponse request
	GetMovieTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetMovieTranslationResponse, error)

	// GetAllPeopleWithResponse request
	GetAllPeopleWithResponse(ctx context.Context, params *GetAllPeopleParams, reqEditors ...RequestEditorFn) (*GetAllPeopleResponse, error)

	// GetAllPeopleTypesWithResponse request
	GetAllPeopleTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllPeopleTypesResponse, error)

	// GetPeopleBaseWithResponse request
	GetPeopleBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetPeopleBaseResponse, error)

	// GetPeopleExtendedWithResponse request
	GetPeopleExtendedWithResponse(ctx context.Context, id float32, params *GetPeopleExtendedParams, reqEditors ...RequestEditorFn) (*GetPeopleExtendedResponse, error)

	// GetPeopleTranslationWithResponse request
	GetPeopleTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetPeopleTranslationResponse, error)

	// GetSearchResultsWithResponse request
	GetSearchResultsWithResponse(ctx context.Context, params *GetSearchResultsParams, reqEditors ...RequestEditorFn) (*GetSearchResultsResponse, error)

	// GetSearchResultsByRemoteIdWithResponse request
	GetSearchResultsByRemoteIdWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*GetSearchResultsByRemoteIdResponse, error)

	// GetAllSeasonsWithResponse request
	GetAllSeasonsWithResponse(ctx context.Context, params *GetAllSeasonsParams, reqEditors ...RequestEditorFn) (*GetAllSeasonsResponse, error)

	// GetSeasonTypesWithResponse request
	GetSeasonTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSeasonTypesResponse, error)

	// GetSeasonBaseWithResponse request
	GetSeasonBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetSeasonBaseResponse, error)

	// GetSeasonExtendedWithResponse request
	GetSeasonExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetSeasonExtendedResponse, error)

	// GetSeasonTranslationWithResponse request
	GetSeasonTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetSeasonTranslationResponse, error)

	// GetAllSeriesWithResponse request
	GetAllSeriesWithResponse(ctx context.Context, params *GetAllSeriesParams, reqEditors ...RequestEditorFn) (*GetAllSeriesResponse, error)

	// GetSeriesFilterWithResponse request
	GetSeriesFilterWithResponse(ctx context.Context, params *GetSeriesFilterParams, reqEditors ...RequestEditorFn) (*GetSeriesFilterResponse, error)

	// GetSeriesBaseBySlugWithResponse request
	GetSeriesBaseBySlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetSeriesBaseBySlugResponse, error)

	// GetAllSeriesStatusesWithResponse request
	GetAllSeriesStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSeriesStatusesResponse, error)

	// GetSeriesBaseWithResponse request
	GetSeriesBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetSeriesBaseResponse, error)

	// GetSeriesArtworksWithResponse request
	GetSeriesArtworksWithResponse(ctx context.Context, id float32, params *GetSeriesArtworksParams, reqEditors ...RequestEditorFn) (*GetSeriesArtworksResponse, error)

	// GetSeriesEpisodesWithResponse request
	GetSeriesEpisodesWithResponse(ctx context.Context, id float32, seasonType string, params *GetSeriesEpisodesParams, reqEditors ...RequestEditorFn) (*GetSeriesEpisodesResponse, error)

	// GetSeriesSeasonEpisodesTranslatedWithResponse request
	GetSeriesSeasonEpisodesTranslatedWithResponse(ctx context.Context, id float32, seasonType string, lang string, params *GetSeriesSeasonEpisodesTranslatedParams, reqEditors ...RequestEditorFn) (*GetSeriesSeasonEpisodesTranslatedResponse, error)

	// GetSeriesExtendedWithResponse request
	GetSeriesExtendedWithResponse(ctx context.Context, id float32, params *GetSeriesExtendedParams, reqEditors ...RequestEditorFn) (*GetSeriesExtendedResponse, error)

	// GetSeriesNextAiredWithResponse request
	GetSeriesNextAiredWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetSeriesNextAiredResponse, error)

	// GetSeriesTranslationWithResponse request
	GetSeriesTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetSeriesTranslationResponse, error)

	// GetAllSourceTypesWithResponse request
	GetAllSourceTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSourceTypesResponse, error)

	// UpdatesWithResponse request
	UpdatesWithResponse(ctx context.Context, params *UpdatesParams, reqEditors ...RequestEditorFn) (*UpdatesResponse, error)

	// GetUserInfoWithResponse request
	GetUserInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error)

	// GetUserFavoritesWithResponse request
	GetUserFavoritesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserFavoritesResponse, error)

	// CreateUserFavoritesWithBodyWithResponse request with any body
	CreateUserFavoritesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserFavoritesResponse, error)

	CreateUserFavoritesWithResponse(ctx context.Context, body CreateUserFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserFavoritesResponse, error)

	// GetUserInfoByIdWithResponse request
	GetUserInfoByIdWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetUserInfoByIdResponse, error)
}

type GetAllArtworkStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ArtworkStatus `json:"data,omitempty"`
		Status *string          `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllArtworkStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllArtworkStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllArtworkTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ArtworkType `json:"data,omitempty"`
		Status *string        `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllArtworkTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllArtworkTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArtworkBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base artwork record
		Data   *ArtworkBaseRecord `json:"data,omitempty"`
		Status *string            `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetArtworkBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArtworkBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArtworkExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data extended artwork record
		Data   *ArtworkExtendedRecord `json:"data,omitempty"`
		Status *string                `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetArtworkExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArtworkExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAwardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]AwardBaseRecord `json:"data,omitempty"`
		Status *string            `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllAwardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAwardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAwardCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base award category record
		Data   *AwardCategoryBaseRecord `json:"data,omitempty"`
		Status *string                  `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAwardCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAwardCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAwardCategoryExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data extended award category record
		Data   *AwardCategoryExtendedRecord `json:"data,omitempty"`
		Status *string                      `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAwardCategoryExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAwardCategoryExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base award record
		Data   *AwardBaseRecord `json:"data,omitempty"`
		Status *string          `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAwardExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data extended award record
		Data   *AwardExtendedRecord `json:"data,omitempty"`
		Status *string              `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAwardExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAwardExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharacterBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data character record
		Data   *Character `json:"data,omitempty"`
		Status *string    `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCharacterBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharacterBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]Company `json:"data,omitempty"`

		// Links Links for next, previous and current record
		Links  *Links  `json:"links,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]CompanyType `json:"data,omitempty"`
		Status *string        `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCompanyTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A company record
		Data   *Company `json:"data,omitempty"`
		Status *string  `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllContentRatingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]ContentRating `json:"data,omitempty"`
		Status *string          `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllContentRatingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllContentRatingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCountriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]Country `json:"data,omitempty"`
		Status *string    `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllCountriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCountriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]EntityType `json:"data,omitempty"`
		Status *string       `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEntityTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]EpisodeBaseRecord `json:"data,omitempty"`

		// Links Links for next, previous and current record
		Links  *Links  `json:"links,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEpisodeBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base episode record
		Data   *EpisodeBaseRecord `json:"data,omitempty"`
		Status *string            `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEpisodeBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEpisodeBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEpisodeExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data extended episode record
		Data   *EpisodeExtendedRecord `json:"data,omitempty"`
		Status *string                `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEpisodeExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEpisodeExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEpisodeTranslationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data translation record
		Data   *Translation `json:"data,omitempty"`
		Status *string      `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEpisodeTranslationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEpisodeTranslationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllGendersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]Gender `json:"data,omitempty"`
		Status *string   `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllGendersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllGendersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllGenresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]GenreBaseRecord `json:"data,omitempty"`
		Status *string            `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllGenresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllGenresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGenreBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base genre record
		Data   *GenreBaseRecord `json:"data,omitempty"`
		Status *string          `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGenreBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGenreBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllInspirationTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]InspirationType `json:"data,omitempty"`
		Status *string            `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllInspirationTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllInspirationTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLanguagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]Language `json:"data,omitempty"`
		Status *string     `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllLanguagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLanguagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ListBaseRecord `json:"data,omitempty"`

		// Links Links for next, previous and current record
		Links  *Links  `json:"links,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListBySlugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base list record
		Data   *ListBaseRecord `json:"data,omitempty"`
		Status *string         `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetListBySlugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListBySlugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base list record
		Data   *ListBaseRecord `json:"data,omitempty"`
		Status *string         `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data extended list record
		Data   *ListExtendedRecord `json:"data,omitempty"`
		Status *string             `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetListExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListTranslationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]Translation `json:"data,omitempty"`
		Status *string        `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetListTranslationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListTranslationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Token *string `json:"token,omitempty"`
		} `json:"data,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllMovieResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]MovieBaseRecord `json:"data,omitempty"`

		// Links Links for next, previous and current record
		Links  *Links  `json:"links,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllMovieResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllMovieResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMoviesFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]MovieBaseRecord `json:"data,omitempty"`
		Status *string            `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMoviesFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMoviesFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMovieBaseBySlugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base movie record
		Data   *MovieBaseRecord `json:"data,omitempty"`
		Status *string          `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMovieBaseBySlugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMovieBaseBySlugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllMovieStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]Status `json:"data,omitempty"`
		Status *string   `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllMovieStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllMovieStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMovieBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base movie record
		Data   *MovieBaseRecord `json:"data,omitempty"`
		Status *string          `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMovieBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMovieBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMovieExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data extended movie record
		Data   *MovieExtendedRecord `json:"data,omitempty"`
		Status *string              `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMovieExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMovieExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMovieTranslationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data translation record
		Data   *Translation `json:"data,omitempty"`
		Status *string      `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMovieTranslationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMovieTranslationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]PeopleBaseRecord `json:"data,omitempty"`

		// Links Links for next, previous and current record
		Links  *Links  `json:"links,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllPeopleTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]PeopleType `json:"data,omitempty"`
		Status *string       `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllPeopleTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllPeopleTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeopleBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data base people record
		Data   *PeopleBaseRecord `json:"data,omitempty"`
		Status *string           `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPeopleBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeopleBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeopleExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data extended people record
		Data   *PeopleExtendedRecord `json:"data,omitempty"`
		Status *string               `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPeopleExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeopleExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeopleTranslationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data translation record
		Data   *Translation `json:"data,omitempty"`
		Status *string      `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPeopleTranslationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeopleTranslationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]SearchResult `json:"data,omitempty"`

		// Links Links for next, previous and current record
		Links  *Links  `json:"links,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultsByRemoteIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]SearchByRemoteIdResult `json:"data,omitempty"`
		Status *string                   `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSearchResultsByRemoteIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultsByRemoteIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSeasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]SeasonBaseRecord `json:"data,omitempty"`
		Status *string             `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllSeasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSeasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]SeasonType `json:"data,omitempty"`
		Status *string       `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeasonTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data season genre record
		Data   *SeasonBaseRecord `json:"data,omitempty"`
		Status *string           `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeasonBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data extended season record
		Data   *SeasonExtendedRecord `json:"data,omitempty"`
		Status *string               `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeasonExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonTranslationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data translation record
		Data   *Translation `json:"data,omitempty"`
		Status *string      `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeasonTranslationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonTranslationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]SeriesBaseRecord `json:"data,omitempty"`

		// Links Links for next, previous and current record
		Links  *Links  `json:"links,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]SeriesBaseRecord `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeriesFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesBaseBySlugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
		Data   *SeriesBaseRecord `json:"data,omitempty"`
		Status *string           `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeriesBaseBySlugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesBaseBySlugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSeriesStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]Status `json:"data,omitempty"`
		Status *string   `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllSeriesStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSeriesStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
		Data   *SeriesBaseRecord `json:"data,omitempty"`
		Status *string           `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeriesBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesArtworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The extended record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
		Data   *SeriesExtendedRecord `json:"data,omitempty"`
		Status *string               `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeriesArtworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesArtworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Episodes *[]EpisodeBaseRecord `json:"episodes,omitempty"`

			// Series The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
			Series *SeriesBaseRecord `json:"series,omitempty"`
		} `json:"data,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeriesEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesSeasonEpisodesTranslatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Series The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
			Series *SeriesBaseRecord `json:"series,omitempty"`
		} `json:"data,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeriesSeasonEpisodesTranslatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesSeasonEpisodesTranslatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesExtendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The extended record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
		Data   *SeriesExtendedRecord `json:"data,omitempty"`
		Status *string               `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeriesExtendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesExtendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesNextAiredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
		Data   *SeriesBaseRecord `json:"data,omitempty"`
		Status *string           `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeriesNextAiredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesNextAiredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesTranslationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data translation record
		Data   *Translation `json:"data,omitempty"`
		Status *string      `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSeriesTranslationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesTranslationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSourceTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]SourceType `json:"data,omitempty"`
		Status *string       `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllSourceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSourceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]EntityUpdate `json:"data,omitempty"`

		// Links Links for next, previous and current record
		Links  *Links  `json:"links,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *interface{} `json:"data,omitempty"`
		Status *string      `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *interface{} `json:"data,omitempty"`
		Status *string      `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateUserFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserInfoByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *interface{} `json:"data,omitempty"`
		Status *string      `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserInfoByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserInfoByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllArtworkStatusesWithResponse request returning *GetAllArtworkStatusesResponse
func (c *ClientWithResponses) GetAllArtworkStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllArtworkStatusesResponse, error) {
	rsp, err := c.GetAllArtworkStatuses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllArtworkStatusesResponse(rsp)
}

// GetAllArtworkTypesWithResponse request returning *GetAllArtworkTypesResponse
func (c *ClientWithResponses) GetAllArtworkTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllArtworkTypesResponse, error) {
	rsp, err := c.GetAllArtworkTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllArtworkTypesResponse(rsp)
}

// GetArtworkBaseWithResponse request returning *GetArtworkBaseResponse
func (c *ClientWithResponses) GetArtworkBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetArtworkBaseResponse, error) {
	rsp, err := c.GetArtworkBase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArtworkBaseResponse(rsp)
}

// GetArtworkExtendedWithResponse request returning *GetArtworkExtendedResponse
func (c *ClientWithResponses) GetArtworkExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetArtworkExtendedResponse, error) {
	rsp, err := c.GetArtworkExtended(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArtworkExtendedResponse(rsp)
}

// GetAllAwardsWithResponse request returning *GetAllAwardsResponse
func (c *ClientWithResponses) GetAllAwardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllAwardsResponse, error) {
	rsp, err := c.GetAllAwards(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAwardsResponse(rsp)
}

// GetAwardCategoryWithResponse request returning *GetAwardCategoryResponse
func (c *ClientWithResponses) GetAwardCategoryWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetAwardCategoryResponse, error) {
	rsp, err := c.GetAwardCategory(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAwardCategoryResponse(rsp)
}

// GetAwardCategoryExtendedWithResponse request returning *GetAwardCategoryExtendedResponse
func (c *ClientWithResponses) GetAwardCategoryExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetAwardCategoryExtendedResponse, error) {
	rsp, err := c.GetAwardCategoryExtended(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAwardCategoryExtendedResponse(rsp)
}

// GetAwardWithResponse request returning *GetAwardResponse
func (c *ClientWithResponses) GetAwardWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetAwardResponse, error) {
	rsp, err := c.GetAward(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAwardResponse(rsp)
}

// GetAwardExtendedWithResponse request returning *GetAwardExtendedResponse
func (c *ClientWithResponses) GetAwardExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetAwardExtendedResponse, error) {
	rsp, err := c.GetAwardExtended(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAwardExtendedResponse(rsp)
}

// GetCharacterBaseWithResponse request returning *GetCharacterBaseResponse
func (c *ClientWithResponses) GetCharacterBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetCharacterBaseResponse, error) {
	rsp, err := c.GetCharacterBase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCharacterBaseResponse(rsp)
}

// GetAllCompaniesWithResponse request returning *GetAllCompaniesResponse
func (c *ClientWithResponses) GetAllCompaniesWithResponse(ctx context.Context, params *GetAllCompaniesParams, reqEditors ...RequestEditorFn) (*GetAllCompaniesResponse, error) {
	rsp, err := c.GetAllCompanies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCompaniesResponse(rsp)
}

// GetCompanyTypesWithResponse request returning *GetCompanyTypesResponse
func (c *ClientWithResponses) GetCompanyTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCompanyTypesResponse, error) {
	rsp, err := c.GetCompanyTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyTypesResponse(rsp)
}

// GetCompanyWithResponse request returning *GetCompanyResponse
func (c *ClientWithResponses) GetCompanyWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetCompanyResponse, error) {
	rsp, err := c.GetCompany(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyResponse(rsp)
}

// GetAllContentRatingsWithResponse request returning *GetAllContentRatingsResponse
func (c *ClientWithResponses) GetAllContentRatingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllContentRatingsResponse, error) {
	rsp, err := c.GetAllContentRatings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllContentRatingsResponse(rsp)
}

// GetAllCountriesWithResponse request returning *GetAllCountriesResponse
func (c *ClientWithResponses) GetAllCountriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCountriesResponse, error) {
	rsp, err := c.GetAllCountries(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCountriesResponse(rsp)
}

// GetEntityTypesWithResponse request returning *GetEntityTypesResponse
func (c *ClientWithResponses) GetEntityTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEntityTypesResponse, error) {
	rsp, err := c.GetEntityTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityTypesResponse(rsp)
}

// GetAllEpisodesWithResponse request returning *GetAllEpisodesResponse
func (c *ClientWithResponses) GetAllEpisodesWithResponse(ctx context.Context, params *GetAllEpisodesParams, reqEditors ...RequestEditorFn) (*GetAllEpisodesResponse, error) {
	rsp, err := c.GetAllEpisodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllEpisodesResponse(rsp)
}

// GetEpisodeBaseWithResponse request returning *GetEpisodeBaseResponse
func (c *ClientWithResponses) GetEpisodeBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetEpisodeBaseResponse, error) {
	rsp, err := c.GetEpisodeBase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEpisodeBaseResponse(rsp)
}

// GetEpisodeExtendedWithResponse request returning *GetEpisodeExtendedResponse
func (c *ClientWithResponses) GetEpisodeExtendedWithResponse(ctx context.Context, id float32, params *GetEpisodeExtendedParams, reqEditors ...RequestEditorFn) (*GetEpisodeExtendedResponse, error) {
	rsp, err := c.GetEpisodeExtended(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEpisodeExtendedResponse(rsp)
}

// GetEpisodeTranslationWithResponse request returning *GetEpisodeTranslationResponse
func (c *ClientWithResponses) GetEpisodeTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetEpisodeTranslationResponse, error) {
	rsp, err := c.GetEpisodeTranslation(ctx, id, language, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEpisodeTranslationResponse(rsp)
}

// GetAllGendersWithResponse request returning *GetAllGendersResponse
func (c *ClientWithResponses) GetAllGendersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllGendersResponse, error) {
	rsp, err := c.GetAllGenders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllGendersResponse(rsp)
}

// GetAllGenresWithResponse request returning *GetAllGenresResponse
func (c *ClientWithResponses) GetAllGenresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllGenresResponse, error) {
	rsp, err := c.GetAllGenres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllGenresResponse(rsp)
}

// GetGenreBaseWithResponse request returning *GetGenreBaseResponse
func (c *ClientWithResponses) GetGenreBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetGenreBaseResponse, error) {
	rsp, err := c.GetGenreBase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGenreBaseResponse(rsp)
}

// GetAllInspirationTypesWithResponse request returning *GetAllInspirationTypesResponse
func (c *ClientWithResponses) GetAllInspirationTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllInspirationTypesResponse, error) {
	rsp, err := c.GetAllInspirationTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllInspirationTypesResponse(rsp)
}

// GetAllLanguagesWithResponse request returning *GetAllLanguagesResponse
func (c *ClientWithResponses) GetAllLanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllLanguagesResponse, error) {
	rsp, err := c.GetAllLanguages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLanguagesResponse(rsp)
}

// GetAllListsWithResponse request returning *GetAllListsResponse
func (c *ClientWithResponses) GetAllListsWithResponse(ctx context.Context, params *GetAllListsParams, reqEditors ...RequestEditorFn) (*GetAllListsResponse, error) {
	rsp, err := c.GetAllLists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllListsResponse(rsp)
}

// GetListBySlugWithResponse request returning *GetListBySlugResponse
func (c *ClientWithResponses) GetListBySlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetListBySlugResponse, error) {
	rsp, err := c.GetListBySlug(ctx, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListBySlugResponse(rsp)
}

// GetListWithResponse request returning *GetListResponse
func (c *ClientWithResponses) GetListWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetListResponse, error) {
	rsp, err := c.GetList(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListResponse(rsp)
}

// GetListExtendedWithResponse request returning *GetListExtendedResponse
func (c *ClientWithResponses) GetListExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetListExtendedResponse, error) {
	rsp, err := c.GetListExtended(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListExtendedResponse(rsp)
}

// GetListTranslationWithResponse request returning *GetListTranslationResponse
func (c *ClientWithResponses) GetListTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetListTranslationResponse, error) {
	rsp, err := c.GetListTranslation(ctx, id, language, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListTranslationResponse(rsp)
}

// PostLoginWithBodyWithResponse request with arbitrary body returning *PostLoginResponse
func (c *ClientWithResponses) PostLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLoginResponse, error) {
	rsp, err := c.PostLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLoginResponse(rsp)
}

func (c *ClientWithResponses) PostLoginWithResponse(ctx context.Context, body PostLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLoginResponse, error) {
	rsp, err := c.PostLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLoginResponse(rsp)
}

// GetAllMovieWithResponse request returning *GetAllMovieResponse
func (c *ClientWithResponses) GetAllMovieWithResponse(ctx context.Context, params *GetAllMovieParams, reqEditors ...RequestEditorFn) (*GetAllMovieResponse, error) {
	rsp, err := c.GetAllMovie(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllMovieResponse(rsp)
}

// GetMoviesFilterWithResponse request returning *GetMoviesFilterResponse
func (c *ClientWithResponses) GetMoviesFilterWithResponse(ctx context.Context, params *GetMoviesFilterParams, reqEditors ...RequestEditorFn) (*GetMoviesFilterResponse, error) {
	rsp, err := c.GetMoviesFilter(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMoviesFilterResponse(rsp)
}

// GetMovieBaseBySlugWithResponse request returning *GetMovieBaseBySlugResponse
func (c *ClientWithResponses) GetMovieBaseBySlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetMovieBaseBySlugResponse, error) {
	rsp, err := c.GetMovieBaseBySlug(ctx, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMovieBaseBySlugResponse(rsp)
}

// GetAllMovieStatusesWithResponse request returning *GetAllMovieStatusesResponse
func (c *ClientWithResponses) GetAllMovieStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllMovieStatusesResponse, error) {
	rsp, err := c.GetAllMovieStatuses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllMovieStatusesResponse(rsp)
}

// GetMovieBaseWithResponse request returning *GetMovieBaseResponse
func (c *ClientWithResponses) GetMovieBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetMovieBaseResponse, error) {
	rsp, err := c.GetMovieBase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMovieBaseResponse(rsp)
}

// GetMovieExtendedWithResponse request returning *GetMovieExtendedResponse
func (c *ClientWithResponses) GetMovieExtendedWithResponse(ctx context.Context, id float32, params *GetMovieExtendedParams, reqEditors ...RequestEditorFn) (*GetMovieExtendedResponse, error) {
	rsp, err := c.GetMovieExtended(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMovieExtendedResponse(rsp)
}

// GetMovieTranslationWithResponse request returning *GetMovieTranslationResponse
func (c *ClientWithResponses) GetMovieTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetMovieTranslationResponse, error) {
	rsp, err := c.GetMovieTranslation(ctx, id, language, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMovieTranslationResponse(rsp)
}

// GetAllPeopleWithResponse request returning *GetAllPeopleResponse
func (c *ClientWithResponses) GetAllPeopleWithResponse(ctx context.Context, params *GetAllPeopleParams, reqEditors ...RequestEditorFn) (*GetAllPeopleResponse, error) {
	rsp, err := c.GetAllPeople(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllPeopleResponse(rsp)
}

// GetAllPeopleTypesWithResponse request returning *GetAllPeopleTypesResponse
func (c *ClientWithResponses) GetAllPeopleTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllPeopleTypesResponse, error) {
	rsp, err := c.GetAllPeopleTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllPeopleTypesResponse(rsp)
}

// GetPeopleBaseWithResponse request returning *GetPeopleBaseResponse
func (c *ClientWithResponses) GetPeopleBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetPeopleBaseResponse, error) {
	rsp, err := c.GetPeopleBase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeopleBaseResponse(rsp)
}

// GetPeopleExtendedWithResponse request returning *GetPeopleExtendedResponse
func (c *ClientWithResponses) GetPeopleExtendedWithResponse(ctx context.Context, id float32, params *GetPeopleExtendedParams, reqEditors ...RequestEditorFn) (*GetPeopleExtendedResponse, error) {
	rsp, err := c.GetPeopleExtended(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeopleExtendedResponse(rsp)
}

// GetPeopleTranslationWithResponse request returning *GetPeopleTranslationResponse
func (c *ClientWithResponses) GetPeopleTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetPeopleTranslationResponse, error) {
	rsp, err := c.GetPeopleTranslation(ctx, id, language, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeopleTranslationResponse(rsp)
}

// GetSearchResultsWithResponse request returning *GetSearchResultsResponse
func (c *ClientWithResponses) GetSearchResultsWithResponse(ctx context.Context, params *GetSearchResultsParams, reqEditors ...RequestEditorFn) (*GetSearchResultsResponse, error) {
	rsp, err := c.GetSearchResults(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultsResponse(rsp)
}

// GetSearchResultsByRemoteIdWithResponse request returning *GetSearchResultsByRemoteIdResponse
func (c *ClientWithResponses) GetSearchResultsByRemoteIdWithResponse(ctx context.Context, remoteId string, reqEditors ...RequestEditorFn) (*GetSearchResultsByRemoteIdResponse, error) {
	rsp, err := c.GetSearchResultsByRemoteId(ctx, remoteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultsByRemoteIdResponse(rsp)
}

// GetAllSeasonsWithResponse request returning *GetAllSeasonsResponse
func (c *ClientWithResponses) GetAllSeasonsWithResponse(ctx context.Context, params *GetAllSeasonsParams, reqEditors ...RequestEditorFn) (*GetAllSeasonsResponse, error) {
	rsp, err := c.GetAllSeasons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSeasonsResponse(rsp)
}

// GetSeasonTypesWithResponse request returning *GetSeasonTypesResponse
func (c *ClientWithResponses) GetSeasonTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSeasonTypesResponse, error) {
	rsp, err := c.GetSeasonTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonTypesResponse(rsp)
}

// GetSeasonBaseWithResponse request returning *GetSeasonBaseResponse
func (c *ClientWithResponses) GetSeasonBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetSeasonBaseResponse, error) {
	rsp, err := c.GetSeasonBase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonBaseResponse(rsp)
}

// GetSeasonExtendedWithResponse request returning *GetSeasonExtendedResponse
func (c *ClientWithResponses) GetSeasonExtendedWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetSeasonExtendedResponse, error) {
	rsp, err := c.GetSeasonExtended(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonExtendedResponse(rsp)
}

// GetSeasonTranslationWithResponse request returning *GetSeasonTranslationResponse
func (c *ClientWithResponses) GetSeasonTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetSeasonTranslationResponse, error) {
	rsp, err := c.GetSeasonTranslation(ctx, id, language, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonTranslationResponse(rsp)
}

// GetAllSeriesWithResponse request returning *GetAllSeriesResponse
func (c *ClientWithResponses) GetAllSeriesWithResponse(ctx context.Context, params *GetAllSeriesParams, reqEditors ...RequestEditorFn) (*GetAllSeriesResponse, error) {
	rsp, err := c.GetAllSeries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSeriesResponse(rsp)
}

// GetSeriesFilterWithResponse request returning *GetSeriesFilterResponse
func (c *ClientWithResponses) GetSeriesFilterWithResponse(ctx context.Context, params *GetSeriesFilterParams, reqEditors ...RequestEditorFn) (*GetSeriesFilterResponse, error) {
	rsp, err := c.GetSeriesFilter(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesFilterResponse(rsp)
}

// GetSeriesBaseBySlugWithResponse request returning *GetSeriesBaseBySlugResponse
func (c *ClientWithResponses) GetSeriesBaseBySlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetSeriesBaseBySlugResponse, error) {
	rsp, err := c.GetSeriesBaseBySlug(ctx, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesBaseBySlugResponse(rsp)
}

// GetAllSeriesStatusesWithResponse request returning *GetAllSeriesStatusesResponse
func (c *ClientWithResponses) GetAllSeriesStatusesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSeriesStatusesResponse, error) {
	rsp, err := c.GetAllSeriesStatuses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSeriesStatusesResponse(rsp)
}

// GetSeriesBaseWithResponse request returning *GetSeriesBaseResponse
func (c *ClientWithResponses) GetSeriesBaseWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetSeriesBaseResponse, error) {
	rsp, err := c.GetSeriesBase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesBaseResponse(rsp)
}

// GetSeriesArtworksWithResponse request returning *GetSeriesArtworksResponse
func (c *ClientWithResponses) GetSeriesArtworksWithResponse(ctx context.Context, id float32, params *GetSeriesArtworksParams, reqEditors ...RequestEditorFn) (*GetSeriesArtworksResponse, error) {
	rsp, err := c.GetSeriesArtworks(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesArtworksResponse(rsp)
}

// GetSeriesEpisodesWithResponse request returning *GetSeriesEpisodesResponse
func (c *ClientWithResponses) GetSeriesEpisodesWithResponse(ctx context.Context, id float32, seasonType string, params *GetSeriesEpisodesParams, reqEditors ...RequestEditorFn) (*GetSeriesEpisodesResponse, error) {
	rsp, err := c.GetSeriesEpisodes(ctx, id, seasonType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesEpisodesResponse(rsp)
}

// GetSeriesSeasonEpisodesTranslatedWithResponse request returning *GetSeriesSeasonEpisodesTranslatedResponse
func (c *ClientWithResponses) GetSeriesSeasonEpisodesTranslatedWithResponse(ctx context.Context, id float32, seasonType string, lang string, params *GetSeriesSeasonEpisodesTranslatedParams, reqEditors ...RequestEditorFn) (*GetSeriesSeasonEpisodesTranslatedResponse, error) {
	rsp, err := c.GetSeriesSeasonEpisodesTranslated(ctx, id, seasonType, lang, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesSeasonEpisodesTranslatedResponse(rsp)
}

// GetSeriesExtendedWithResponse request returning *GetSeriesExtendedResponse
func (c *ClientWithResponses) GetSeriesExtendedWithResponse(ctx context.Context, id float32, params *GetSeriesExtendedParams, reqEditors ...RequestEditorFn) (*GetSeriesExtendedResponse, error) {
	rsp, err := c.GetSeriesExtended(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesExtendedResponse(rsp)
}

// GetSeriesNextAiredWithResponse request returning *GetSeriesNextAiredResponse
func (c *ClientWithResponses) GetSeriesNextAiredWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetSeriesNextAiredResponse, error) {
	rsp, err := c.GetSeriesNextAired(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesNextAiredResponse(rsp)
}

// GetSeriesTranslationWithResponse request returning *GetSeriesTranslationResponse
func (c *ClientWithResponses) GetSeriesTranslationWithResponse(ctx context.Context, id float32, language string, reqEditors ...RequestEditorFn) (*GetSeriesTranslationResponse, error) {
	rsp, err := c.GetSeriesTranslation(ctx, id, language, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesTranslationResponse(rsp)
}

// GetAllSourceTypesWithResponse request returning *GetAllSourceTypesResponse
func (c *ClientWithResponses) GetAllSourceTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSourceTypesResponse, error) {
	rsp, err := c.GetAllSourceTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSourceTypesResponse(rsp)
}

// UpdatesWithResponse request returning *UpdatesResponse
func (c *ClientWithResponses) UpdatesWithResponse(ctx context.Context, params *UpdatesParams, reqEditors ...RequestEditorFn) (*UpdatesResponse, error) {
	rsp, err := c.Updates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatesResponse(rsp)
}

// GetUserInfoWithResponse request returning *GetUserInfoResponse
func (c *ClientWithResponses) GetUserInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error) {
	rsp, err := c.GetUserInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserInfoResponse(rsp)
}

// GetUserFavoritesWithResponse request returning *GetUserFavoritesResponse
func (c *ClientWithResponses) GetUserFavoritesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserFavoritesResponse, error) {
	rsp, err := c.GetUserFavorites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFavoritesResponse(rsp)
}

// CreateUserFavoritesWithBodyWithResponse request with arbitrary body returning *CreateUserFavoritesResponse
func (c *ClientWithResponses) CreateUserFavoritesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserFavoritesResponse, error) {
	rsp, err := c.CreateUserFavoritesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserFavoritesResponse(rsp)
}

func (c *ClientWithResponses) CreateUserFavoritesWithResponse(ctx context.Context, body CreateUserFavoritesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserFavoritesResponse, error) {
	rsp, err := c.CreateUserFavorites(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserFavoritesResponse(rsp)
}

// GetUserInfoByIdWithResponse request returning *GetUserInfoByIdResponse
func (c *ClientWithResponses) GetUserInfoByIdWithResponse(ctx context.Context, id float32, reqEditors ...RequestEditorFn) (*GetUserInfoByIdResponse, error) {
	rsp, err := c.GetUserInfoById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserInfoByIdResponse(rsp)
}

// ParseGetAllArtworkStatusesResponse parses an HTTP response from a GetAllArtworkStatusesWithResponse call
func ParseGetAllArtworkStatusesResponse(rsp *http.Response) (*GetAllArtworkStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllArtworkStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ArtworkStatus `json:"data,omitempty"`
			Status *string          `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllArtworkTypesResponse parses an HTTP response from a GetAllArtworkTypesWithResponse call
func ParseGetAllArtworkTypesResponse(rsp *http.Response) (*GetAllArtworkTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllArtworkTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ArtworkType `json:"data,omitempty"`
			Status *string        `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetArtworkBaseResponse parses an HTTP response from a GetArtworkBaseWithResponse call
func ParseGetArtworkBaseResponse(rsp *http.Response) (*GetArtworkBaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArtworkBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base artwork record
			Data   *ArtworkBaseRecord `json:"data,omitempty"`
			Status *string            `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetArtworkExtendedResponse parses an HTTP response from a GetArtworkExtendedWithResponse call
func ParseGetArtworkExtendedResponse(rsp *http.Response) (*GetArtworkExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArtworkExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data extended artwork record
			Data   *ArtworkExtendedRecord `json:"data,omitempty"`
			Status *string                `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllAwardsResponse parses an HTTP response from a GetAllAwardsWithResponse call
func ParseGetAllAwardsResponse(rsp *http.Response) (*GetAllAwardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAwardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]AwardBaseRecord `json:"data,omitempty"`
			Status *string            `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAwardCategoryResponse parses an HTTP response from a GetAwardCategoryWithResponse call
func ParseGetAwardCategoryResponse(rsp *http.Response) (*GetAwardCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAwardCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base award category record
			Data   *AwardCategoryBaseRecord `json:"data,omitempty"`
			Status *string                  `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAwardCategoryExtendedResponse parses an HTTP response from a GetAwardCategoryExtendedWithResponse call
func ParseGetAwardCategoryExtendedResponse(rsp *http.Response) (*GetAwardCategoryExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAwardCategoryExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data extended award category record
			Data   *AwardCategoryExtendedRecord `json:"data,omitempty"`
			Status *string                      `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAwardResponse parses an HTTP response from a GetAwardWithResponse call
func ParseGetAwardResponse(rsp *http.Response) (*GetAwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base award record
			Data   *AwardBaseRecord `json:"data,omitempty"`
			Status *string          `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAwardExtendedResponse parses an HTTP response from a GetAwardExtendedWithResponse call
func ParseGetAwardExtendedResponse(rsp *http.Response) (*GetAwardExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAwardExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data extended award record
			Data   *AwardExtendedRecord `json:"data,omitempty"`
			Status *string              `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharacterBaseResponse parses an HTTP response from a GetCharacterBaseWithResponse call
func ParseGetCharacterBaseResponse(rsp *http.Response) (*GetCharacterBaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCharacterBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data character record
			Data   *Character `json:"data,omitempty"`
			Status *string    `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllCompaniesResponse parses an HTTP response from a GetAllCompaniesWithResponse call
func ParseGetAllCompaniesResponse(rsp *http.Response) (*GetAllCompaniesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]Company `json:"data,omitempty"`

			// Links Links for next, previous and current record
			Links  *Links  `json:"links,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompanyTypesResponse parses an HTTP response from a GetCompanyTypesWithResponse call
func ParseGetCompanyTypesResponse(rsp *http.Response) (*GetCompanyTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]CompanyType `json:"data,omitempty"`
			Status *string        `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompanyResponse parses an HTTP response from a GetCompanyWithResponse call
func ParseGetCompanyResponse(rsp *http.Response) (*GetCompanyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A company record
			Data   *Company `json:"data,omitempty"`
			Status *string  `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllContentRatingsResponse parses an HTTP response from a GetAllContentRatingsWithResponse call
func ParseGetAllContentRatingsResponse(rsp *http.Response) (*GetAllContentRatingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllContentRatingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]ContentRating `json:"data,omitempty"`
			Status *string          `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllCountriesResponse parses an HTTP response from a GetAllCountriesWithResponse call
func ParseGetAllCountriesResponse(rsp *http.Response) (*GetAllCountriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCountriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]Country `json:"data,omitempty"`
			Status *string    `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEntityTypesResponse parses an HTTP response from a GetEntityTypesWithResponse call
func ParseGetEntityTypesResponse(rsp *http.Response) (*GetEntityTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]EntityType `json:"data,omitempty"`
			Status *string       `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllEpisodesResponse parses an HTTP response from a GetAllEpisodesWithResponse call
func ParseGetAllEpisodesResponse(rsp *http.Response) (*GetAllEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]EpisodeBaseRecord `json:"data,omitempty"`

			// Links Links for next, previous and current record
			Links  *Links  `json:"links,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEpisodeBaseResponse parses an HTTP response from a GetEpisodeBaseWithResponse call
func ParseGetEpisodeBaseResponse(rsp *http.Response) (*GetEpisodeBaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEpisodeBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base episode record
			Data   *EpisodeBaseRecord `json:"data,omitempty"`
			Status *string            `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEpisodeExtendedResponse parses an HTTP response from a GetEpisodeExtendedWithResponse call
func ParseGetEpisodeExtendedResponse(rsp *http.Response) (*GetEpisodeExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEpisodeExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data extended episode record
			Data   *EpisodeExtendedRecord `json:"data,omitempty"`
			Status *string                `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEpisodeTranslationResponse parses an HTTP response from a GetEpisodeTranslationWithResponse call
func ParseGetEpisodeTranslationResponse(rsp *http.Response) (*GetEpisodeTranslationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEpisodeTranslationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data translation record
			Data   *Translation `json:"data,omitempty"`
			Status *string      `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllGendersResponse parses an HTTP response from a GetAllGendersWithResponse call
func ParseGetAllGendersResponse(rsp *http.Response) (*GetAllGendersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllGendersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]Gender `json:"data,omitempty"`
			Status *string   `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllGenresResponse parses an HTTP response from a GetAllGenresWithResponse call
func ParseGetAllGenresResponse(rsp *http.Response) (*GetAllGenresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllGenresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]GenreBaseRecord `json:"data,omitempty"`
			Status *string            `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGenreBaseResponse parses an HTTP response from a GetGenreBaseWithResponse call
func ParseGetGenreBaseResponse(rsp *http.Response) (*GetGenreBaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGenreBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base genre record
			Data   *GenreBaseRecord `json:"data,omitempty"`
			Status *string          `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllInspirationTypesResponse parses an HTTP response from a GetAllInspirationTypesWithResponse call
func ParseGetAllInspirationTypesResponse(rsp *http.Response) (*GetAllInspirationTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllInspirationTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]InspirationType `json:"data,omitempty"`
			Status *string            `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllLanguagesResponse parses an HTTP response from a GetAllLanguagesWithResponse call
func ParseGetAllLanguagesResponse(rsp *http.Response) (*GetAllLanguagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLanguagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]Language `json:"data,omitempty"`
			Status *string     `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllListsResponse parses an HTTP response from a GetAllListsWithResponse call
func ParseGetAllListsResponse(rsp *http.Response) (*GetAllListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ListBaseRecord `json:"data,omitempty"`

			// Links Links for next, previous and current record
			Links  *Links  `json:"links,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetListBySlugResponse parses an HTTP response from a GetListBySlugWithResponse call
func ParseGetListBySlugResponse(rsp *http.Response) (*GetListBySlugResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListBySlugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base list record
			Data   *ListBaseRecord `json:"data,omitempty"`
			Status *string         `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetListResponse parses an HTTP response from a GetListWithResponse call
func ParseGetListResponse(rsp *http.Response) (*GetListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base list record
			Data   *ListBaseRecord `json:"data,omitempty"`
			Status *string         `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetListExtendedResponse parses an HTTP response from a GetListExtendedWithResponse call
func ParseGetListExtendedResponse(rsp *http.Response) (*GetListExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data extended list record
			Data   *ListExtendedRecord `json:"data,omitempty"`
			Status *string             `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetListTranslationResponse parses an HTTP response from a GetListTranslationWithResponse call
func ParseGetListTranslationResponse(rsp *http.Response) (*GetListTranslationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListTranslationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]Translation `json:"data,omitempty"`
			Status *string        `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostLoginResponse parses an HTTP response from a PostLoginWithResponse call
func ParsePostLoginResponse(rsp *http.Response) (*PostLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Token *string `json:"token,omitempty"`
			} `json:"data,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllMovieResponse parses an HTTP response from a GetAllMovieWithResponse call
func ParseGetAllMovieResponse(rsp *http.Response) (*GetAllMovieResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllMovieResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]MovieBaseRecord `json:"data,omitempty"`

			// Links Links for next, previous and current record
			Links  *Links  `json:"links,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMoviesFilterResponse parses an HTTP response from a GetMoviesFilterWithResponse call
func ParseGetMoviesFilterResponse(rsp *http.Response) (*GetMoviesFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMoviesFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]MovieBaseRecord `json:"data,omitempty"`
			Status *string            `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMovieBaseBySlugResponse parses an HTTP response from a GetMovieBaseBySlugWithResponse call
func ParseGetMovieBaseBySlugResponse(rsp *http.Response) (*GetMovieBaseBySlugResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMovieBaseBySlugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base movie record
			Data   *MovieBaseRecord `json:"data,omitempty"`
			Status *string          `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllMovieStatusesResponse parses an HTTP response from a GetAllMovieStatusesWithResponse call
func ParseGetAllMovieStatusesResponse(rsp *http.Response) (*GetAllMovieStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllMovieStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]Status `json:"data,omitempty"`
			Status *string   `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMovieBaseResponse parses an HTTP response from a GetMovieBaseWithResponse call
func ParseGetMovieBaseResponse(rsp *http.Response) (*GetMovieBaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMovieBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base movie record
			Data   *MovieBaseRecord `json:"data,omitempty"`
			Status *string          `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMovieExtendedResponse parses an HTTP response from a GetMovieExtendedWithResponse call
func ParseGetMovieExtendedResponse(rsp *http.Response) (*GetMovieExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMovieExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data extended movie record
			Data   *MovieExtendedRecord `json:"data,omitempty"`
			Status *string              `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMovieTranslationResponse parses an HTTP response from a GetMovieTranslationWithResponse call
func ParseGetMovieTranslationResponse(rsp *http.Response) (*GetMovieTranslationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMovieTranslationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data translation record
			Data   *Translation `json:"data,omitempty"`
			Status *string      `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllPeopleResponse parses an HTTP response from a GetAllPeopleWithResponse call
func ParseGetAllPeopleResponse(rsp *http.Response) (*GetAllPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]PeopleBaseRecord `json:"data,omitempty"`

			// Links Links for next, previous and current record
			Links  *Links  `json:"links,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllPeopleTypesResponse parses an HTTP response from a GetAllPeopleTypesWithResponse call
func ParseGetAllPeopleTypesResponse(rsp *http.Response) (*GetAllPeopleTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllPeopleTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]PeopleType `json:"data,omitempty"`
			Status *string       `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPeopleBaseResponse parses an HTTP response from a GetPeopleBaseWithResponse call
func ParseGetPeopleBaseResponse(rsp *http.Response) (*GetPeopleBaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeopleBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data base people record
			Data   *PeopleBaseRecord `json:"data,omitempty"`
			Status *string           `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPeopleExtendedResponse parses an HTTP response from a GetPeopleExtendedWithResponse call
func ParseGetPeopleExtendedResponse(rsp *http.Response) (*GetPeopleExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeopleExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data extended people record
			Data   *PeopleExtendedRecord `json:"data,omitempty"`
			Status *string               `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPeopleTranslationResponse parses an HTTP response from a GetPeopleTranslationWithResponse call
func ParseGetPeopleTranslationResponse(rsp *http.Response) (*GetPeopleTranslationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeopleTranslationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data translation record
			Data   *Translation `json:"data,omitempty"`
			Status *string      `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSearchResultsResponse parses an HTTP response from a GetSearchResultsWithResponse call
func ParseGetSearchResultsResponse(rsp *http.Response) (*GetSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]SearchResult `json:"data,omitempty"`

			// Links Links for next, previous and current record
			Links  *Links  `json:"links,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSearchResultsByRemoteIdResponse parses an HTTP response from a GetSearchResultsByRemoteIdWithResponse call
func ParseGetSearchResultsByRemoteIdResponse(rsp *http.Response) (*GetSearchResultsByRemoteIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultsByRemoteIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]SearchByRemoteIdResult `json:"data,omitempty"`
			Status *string                   `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllSeasonsResponse parses an HTTP response from a GetAllSeasonsWithResponse call
func ParseGetAllSeasonsResponse(rsp *http.Response) (*GetAllSeasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSeasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]SeasonBaseRecord `json:"data,omitempty"`
			Status *string             `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeasonTypesResponse parses an HTTP response from a GetSeasonTypesWithResponse call
func ParseGetSeasonTypesResponse(rsp *http.Response) (*GetSeasonTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]SeasonType `json:"data,omitempty"`
			Status *string       `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeasonBaseResponse parses an HTTP response from a GetSeasonBaseWithResponse call
func ParseGetSeasonBaseResponse(rsp *http.Response) (*GetSeasonBaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data season genre record
			Data   *SeasonBaseRecord `json:"data,omitempty"`
			Status *string           `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeasonExtendedResponse parses an HTTP response from a GetSeasonExtendedWithResponse call
func ParseGetSeasonExtendedResponse(rsp *http.Response) (*GetSeasonExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data extended season record
			Data   *SeasonExtendedRecord `json:"data,omitempty"`
			Status *string               `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeasonTranslationResponse parses an HTTP response from a GetSeasonTranslationWithResponse call
func ParseGetSeasonTranslationResponse(rsp *http.Response) (*GetSeasonTranslationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonTranslationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data translation record
			Data   *Translation `json:"data,omitempty"`
			Status *string      `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllSeriesResponse parses an HTTP response from a GetAllSeriesWithResponse call
func ParseGetAllSeriesResponse(rsp *http.Response) (*GetAllSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]SeriesBaseRecord `json:"data,omitempty"`

			// Links Links for next, previous and current record
			Links  *Links  `json:"links,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesFilterResponse parses an HTTP response from a GetSeriesFilterWithResponse call
func ParseGetSeriesFilterResponse(rsp *http.Response) (*GetSeriesFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]SeriesBaseRecord `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesBaseBySlugResponse parses an HTTP response from a GetSeriesBaseBySlugWithResponse call
func ParseGetSeriesBaseBySlugResponse(rsp *http.Response) (*GetSeriesBaseBySlugResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesBaseBySlugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
			Data   *SeriesBaseRecord `json:"data,omitempty"`
			Status *string           `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllSeriesStatusesResponse parses an HTTP response from a GetAllSeriesStatusesWithResponse call
func ParseGetAllSeriesStatusesResponse(rsp *http.Response) (*GetAllSeriesStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSeriesStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]Status `json:"data,omitempty"`
			Status *string   `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesBaseResponse parses an HTTP response from a GetSeriesBaseWithResponse call
func ParseGetSeriesBaseResponse(rsp *http.Response) (*GetSeriesBaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
			Data   *SeriesBaseRecord `json:"data,omitempty"`
			Status *string           `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesArtworksResponse parses an HTTP response from a GetSeriesArtworksWithResponse call
func ParseGetSeriesArtworksResponse(rsp *http.Response) (*GetSeriesArtworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesArtworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The extended record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
			Data   *SeriesExtendedRecord `json:"data,omitempty"`
			Status *string               `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesEpisodesResponse parses an HTTP response from a GetSeriesEpisodesWithResponse call
func ParseGetSeriesEpisodesResponse(rsp *http.Response) (*GetSeriesEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Episodes *[]EpisodeBaseRecord `json:"episodes,omitempty"`

				// Series The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
				Series *SeriesBaseRecord `json:"series,omitempty"`
			} `json:"data,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesSeasonEpisodesTranslatedResponse parses an HTTP response from a GetSeriesSeasonEpisodesTranslatedWithResponse call
func ParseGetSeriesSeasonEpisodesTranslatedResponse(rsp *http.Response) (*GetSeriesSeasonEpisodesTranslatedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesSeasonEpisodesTranslatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Series The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
				Series *SeriesBaseRecord `json:"series,omitempty"`
			} `json:"data,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesExtendedResponse parses an HTTP response from a GetSeriesExtendedWithResponse call
func ParseGetSeriesExtendedResponse(rsp *http.Response) (*GetSeriesExtendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesExtendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The extended record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
			Data   *SeriesExtendedRecord `json:"data,omitempty"`
			Status *string               `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesNextAiredResponse parses an HTTP response from a GetSeriesNextAiredWithResponse call
func ParseGetSeriesNextAiredResponse(rsp *http.Response) (*GetSeriesNextAiredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesNextAiredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The base record for a series. All series airs time like firstAired, lastAired, nextAired, etc. are in US EST for US series, and for all non-US series, the time of the showâ€™s country capital or most populous city. For streaming services, is the official release time. See https://support.thetvdb.com/kb/faq.php?id=29.
			Data   *SeriesBaseRecord `json:"data,omitempty"`
			Status *string           `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeriesTranslationResponse parses an HTTP response from a GetSeriesTranslationWithResponse call
func ParseGetSeriesTranslationResponse(rsp *http.Response) (*GetSeriesTranslationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesTranslationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data translation record
			Data   *Translation `json:"data,omitempty"`
			Status *string      `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllSourceTypesResponse parses an HTTP response from a GetAllSourceTypesWithResponse call
func ParseGetAllSourceTypesResponse(rsp *http.Response) (*GetAllSourceTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSourceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]SourceType `json:"data,omitempty"`
			Status *string       `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatesResponse parses an HTTP response from a UpdatesWithResponse call
func ParseUpdatesResponse(rsp *http.Response) (*UpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]EntityUpdate `json:"data,omitempty"`

			// Links Links for next, previous and current record
			Links  *Links  `json:"links,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserInfoResponse parses an HTTP response from a GetUserInfoWithResponse call
func ParseGetUserInfoResponse(rsp *http.Response) (*GetUserInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *interface{} `json:"data,omitempty"`
			Status *string      `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFavoritesResponse parses an HTTP response from a GetUserFavoritesWithResponse call
func ParseGetUserFavoritesResponse(rsp *http.Response) (*GetUserFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *interface{} `json:"data,omitempty"`
			Status *string      `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateUserFavoritesResponse parses an HTTP response from a CreateUserFavoritesWithResponse call
func ParseCreateUserFavoritesResponse(rsp *http.Response) (*CreateUserFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserInfoByIdResponse parses an HTTP response from a GetUserInfoByIdWithResponse call
func ParseGetUserInfoByIdResponse(rsp *http.Response) (*GetUserInfoByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserInfoByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *interface{} `json:"data,omitempty"`
			Status *string      `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
